// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rpc.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// RPC-related types. Request messages, response messages, and dependant types.
///
/// Clients are expected to build RequestMessages and wrap them in KaspadMessage. (see messages.proto)
///
/// Having received a RequestMessage, (wrapped in a KaspadMessage) the RPC server will respond with a
/// ResponseMessage (likewise wrapped in a KaspadMessage) respective to the original RequestMessage.
///
/// **IMPORTANT:** This API is a work in progress and is subject to break between versions.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    public struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

public enum Protowire_RpcNotifyCommand: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case notifyStart // = 0
    case notifyStop // = 1
    case UNRECOGNIZED(Int)
    
    public init() {
        self = .notifyStart
    }
    
    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .notifyStart
        case 1: self = .notifyStop
        default: self = .UNRECOGNIZED(rawValue)
        }
    }
    
    public var rawValue: Int {
        switch self {
        case .notifyStart: return 0
        case .notifyStop: return 1
        case .UNRECOGNIZED(let i): return i
        }
    }
    
    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Protowire_RpcNotifyCommand] = [
        .notifyStart,
        .notifyStop,
    ]
    
}

/// RPCError represents a generic non-internal error.
///
/// Receivers of any ResponseMessage are expected to check whether its error field is not null.
public struct Protowire_RPCError: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var message: String = String()
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_RpcBlock: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var header: Protowire_RpcBlockHeader {
        get {return _storage._header ?? Protowire_RpcBlockHeader()}
        set {_uniqueStorage()._header = newValue}
    }
    /// Returns true if `header` has been explicitly set.
    public var hasHeader: Bool {return _storage._header != nil}
    /// Clears the value of `header`. Subsequent reads from it will return its default value.
    public mutating func clearHeader() {_uniqueStorage()._header = nil}
    
    public var transactions: [Protowire_RpcTransaction] {
        get {return _storage._transactions}
        set {_uniqueStorage()._transactions = newValue}
    }
    
    public var verboseData: Protowire_RpcBlockVerboseData {
        get {return _storage._verboseData ?? Protowire_RpcBlockVerboseData()}
        set {_uniqueStorage()._verboseData = newValue}
    }
    /// Returns true if `verboseData` has been explicitly set.
    public var hasVerboseData: Bool {return _storage._verboseData != nil}
    /// Clears the value of `verboseData`. Subsequent reads from it will return its default value.
    public mutating func clearVerboseData() {_uniqueStorage()._verboseData = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Protowire_RpcBlockHeader: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var version: UInt32 = 0
    
    public var parents: [Protowire_RpcBlockLevelParents] = []
    
    public var hashMerkleRoot: String = String()
    
    public var acceptedIDMerkleRoot: String = String()
    
    public var utxoCommitment: String = String()
    
    public var timestamp: Int64 = 0
    
    public var bits: UInt32 = 0
    
    public var nonce: UInt64 = 0
    
    public var daaScore: UInt64 = 0
    
    public var blueWork: String = String()
    
    public var pruningPoint: String = String()
    
    public var blueScore: UInt64 = 0
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_RpcBlockLevelParents: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var parentHashes: [String] = []
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_RpcBlockVerboseData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var hash: String = String()
    
    public var difficulty: Double = 0
    
    public var selectedParentHash: String = String()
    
    public var transactionIds: [String] = []
    
    public var isHeaderOnly: Bool = false
    
    public var blueScore: UInt64 = 0
    
    public var childrenHashes: [String] = []
    
    public var mergeSetBluesHashes: [String] = []
    
    public var mergeSetRedsHashes: [String] = []
    
    public var isChainBlock: Bool = false
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_RpcTransaction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var version: UInt32 = 0
    
    public var inputs: [Protowire_RpcTransactionInput] = []
    
    public var outputs: [Protowire_RpcTransactionOutput] = []
    
    public var lockTime: UInt64 = 0
    
    public var subnetworkID: String = String()
    
    public var gas: UInt64 = 0
    
    public var payload: String = String()
    
    public var verboseData: Protowire_RpcTransactionVerboseData {
        get {return _verboseData ?? Protowire_RpcTransactionVerboseData()}
        set {_verboseData = newValue}
    }
    /// Returns true if `verboseData` has been explicitly set.
    public var hasVerboseData: Bool {return self._verboseData != nil}
    /// Clears the value of `verboseData`. Subsequent reads from it will return its default value.
    public mutating func clearVerboseData() {self._verboseData = nil}
    
    public var mass: UInt64 = 0
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _verboseData: Protowire_RpcTransactionVerboseData? = nil
}

public struct Protowire_RpcTransactionInput: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var previousOutpoint: Protowire_RpcOutpoint {
        get {return _previousOutpoint ?? Protowire_RpcOutpoint()}
        set {_previousOutpoint = newValue}
    }
    /// Returns true if `previousOutpoint` has been explicitly set.
    public var hasPreviousOutpoint: Bool {return self._previousOutpoint != nil}
    /// Clears the value of `previousOutpoint`. Subsequent reads from it will return its default value.
    public mutating func clearPreviousOutpoint() {self._previousOutpoint = nil}
    
    public var signatureScript: String = String()
    
    public var sequence: UInt64 = 0
    
    public var sigOpCount: UInt32 = 0
    
    public var verboseData: Protowire_RpcTransactionInputVerboseData {
        get {return _verboseData ?? Protowire_RpcTransactionInputVerboseData()}
        set {_verboseData = newValue}
    }
    /// Returns true if `verboseData` has been explicitly set.
    public var hasVerboseData: Bool {return self._verboseData != nil}
    /// Clears the value of `verboseData`. Subsequent reads from it will return its default value.
    public mutating func clearVerboseData() {self._verboseData = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _previousOutpoint: Protowire_RpcOutpoint? = nil
    fileprivate var _verboseData: Protowire_RpcTransactionInputVerboseData? = nil
}

public struct Protowire_RpcScriptPublicKey: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var version: UInt32 = 0
    
    public var scriptPublicKey: String = String()
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_RpcTransactionOutput: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var amount: UInt64 = 0
    
    public var scriptPublicKey: Protowire_RpcScriptPublicKey {
        get {return _scriptPublicKey ?? Protowire_RpcScriptPublicKey()}
        set {_scriptPublicKey = newValue}
    }
    /// Returns true if `scriptPublicKey` has been explicitly set.
    public var hasScriptPublicKey: Bool {return self._scriptPublicKey != nil}
    /// Clears the value of `scriptPublicKey`. Subsequent reads from it will return its default value.
    public mutating func clearScriptPublicKey() {self._scriptPublicKey = nil}
    
    public var verboseData: Protowire_RpcTransactionOutputVerboseData {
        get {return _verboseData ?? Protowire_RpcTransactionOutputVerboseData()}
        set {_verboseData = newValue}
    }
    /// Returns true if `verboseData` has been explicitly set.
    public var hasVerboseData: Bool {return self._verboseData != nil}
    /// Clears the value of `verboseData`. Subsequent reads from it will return its default value.
    public mutating func clearVerboseData() {self._verboseData = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _scriptPublicKey: Protowire_RpcScriptPublicKey? = nil
    fileprivate var _verboseData: Protowire_RpcTransactionOutputVerboseData? = nil
}

public struct Protowire_RpcOutpoint: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var transactionID: String = String()
    
    public var index: UInt32 = 0
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_RpcUtxoEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var amount: UInt64 = 0
    
    public var scriptPublicKey: Protowire_RpcScriptPublicKey {
        get {return _scriptPublicKey ?? Protowire_RpcScriptPublicKey()}
        set {_scriptPublicKey = newValue}
    }
    /// Returns true if `scriptPublicKey` has been explicitly set.
    public var hasScriptPublicKey: Bool {return self._scriptPublicKey != nil}
    /// Clears the value of `scriptPublicKey`. Subsequent reads from it will return its default value.
    public mutating func clearScriptPublicKey() {self._scriptPublicKey = nil}
    
    public var blockDaaScore: UInt64 = 0
    
    public var isCoinbase: Bool = false
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _scriptPublicKey: Protowire_RpcScriptPublicKey? = nil
}

public struct Protowire_RpcTransactionVerboseData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var transactionID: String = String()
    
    public var hash: String = String()
    
    public var mass: UInt64 = 0
    
    public var blockHash: String = String()
    
    public var blockTime: UInt64 = 0
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_RpcTransactionInputVerboseData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_RpcTransactionOutputVerboseData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var scriptPublicKeyType: String = String()
    
    public var scriptPublicKeyAddress: String = String()
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

/// GetCurrentNetworkRequestMessage requests the network kaspad is currently running against.
///
/// Possible networks are: Mainnet, Testnet, Simnet, Devnet
public struct Protowire_GetCurrentNetworkRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetCurrentNetworkResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var currentNetwork: String = String()
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// SubmitBlockRequestMessage requests to submit a block into the DAG.
/// Blocks are generally expected to have been generated using the getBlockTemplate call.
///
/// See: GetBlockTemplateRequestMessage
public struct Protowire_SubmitBlockRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var block: Protowire_RpcBlock {
        get {return _block ?? Protowire_RpcBlock()}
        set {_block = newValue}
    }
    /// Returns true if `block` has been explicitly set.
    public var hasBlock: Bool {return self._block != nil}
    /// Clears the value of `block`. Subsequent reads from it will return its default value.
    public mutating func clearBlock() {self._block = nil}
    
    public var allowNonDaablocks: Bool = false
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _block: Protowire_RpcBlock? = nil
}

public struct Protowire_SubmitBlockResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var rejectReason: Protowire_SubmitBlockResponseMessage.RejectReason = .none
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public enum RejectReason: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int
        case none // = 0
        case blockInvalid // = 1
        case isInIbd // = 2
        case UNRECOGNIZED(Int)
        
        public init() {
            self = .none
        }
        
        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .none
            case 1: self = .blockInvalid
            case 2: self = .isInIbd
            default: self = .UNRECOGNIZED(rawValue)
            }
        }
        
        public var rawValue: Int {
            switch self {
            case .none: return 0
            case .blockInvalid: return 1
            case .isInIbd: return 2
            case .UNRECOGNIZED(let i): return i
            }
        }
        
        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [Protowire_SubmitBlockResponseMessage.RejectReason] = [
            .none,
            .blockInvalid,
            .isInIbd,
        ]
        
    }
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// GetBlockTemplateRequestMessage requests a current block template.
/// Callers are expected to solve the block template and submit it using the submitBlock call
///
/// See: SubmitBlockRequestMessage
public struct Protowire_GetBlockTemplateRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    /// Which kaspa address should the coinbase block reward transaction pay into
    public var payAddress: String = String()
    
    public var extraData: String = String()
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetBlockTemplateResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var block: Protowire_RpcBlock {
        get {return _block ?? Protowire_RpcBlock()}
        set {_block = newValue}
    }
    /// Returns true if `block` has been explicitly set.
    public var hasBlock: Bool {return self._block != nil}
    /// Clears the value of `block`. Subsequent reads from it will return its default value.
    public mutating func clearBlock() {self._block = nil}
    
    /// Whether kaspad thinks that it's synced.
    /// Callers are discouraged (but not forbidden) from solving blocks when kaspad is not synced.
    /// That is because when kaspad isn't in sync with the rest of the network there's a high
    /// chance the block will never be accepted, thus the solving effort would have been wasted.
    public var isSynced: Bool = false
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _block: Protowire_RpcBlock? = nil
    fileprivate var _error: Protowire_RPCError? = nil
}

/// NotifyBlockAddedRequestMessage registers this connection for blockAdded notifications.
///
/// See: BlockAddedNotificationMessage
public struct Protowire_NotifyBlockAddedRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var command: Protowire_RpcNotifyCommand = .notifyStart
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_NotifyBlockAddedResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// BlockAddedNotificationMessage is sent whenever a blocks has been added (NOT accepted)
/// into the DAG.
///
/// See: NotifyBlockAddedRequestMessage
public struct Protowire_BlockAddedNotificationMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var block: Protowire_RpcBlock {
        get {return _block ?? Protowire_RpcBlock()}
        set {_block = newValue}
    }
    /// Returns true if `block` has been explicitly set.
    public var hasBlock: Bool {return self._block != nil}
    /// Clears the value of `block`. Subsequent reads from it will return its default value.
    public mutating func clearBlock() {self._block = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _block: Protowire_RpcBlock? = nil
}

/// GetPeerAddressesRequestMessage requests the list of known kaspad addresses in the
/// current network. (mainnet, testnet, etc.)
public struct Protowire_GetPeerAddressesRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetPeerAddressesResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var addresses: [Protowire_GetPeerAddressesKnownAddressMessage] = []
    
    public var bannedAddresses: [Protowire_GetPeerAddressesKnownAddressMessage] = []
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_GetPeerAddressesKnownAddressMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var addr: String = String()
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

/// GetSinkRequestMessage requests the hash of the current virtual's
/// selected parent.
public struct Protowire_GetSinkRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetSinkResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var sink: String = String()
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// GetMempoolEntryRequestMessage requests information about a specific transaction
/// in the mempool.
public struct Protowire_GetMempoolEntryRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    /// The transaction's TransactionID.
    public var txID: String = String()
    
    public var includeOrphanPool: Bool = false
    
    public var filterTransactionPool: Bool = false
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetMempoolEntryResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var entry: Protowire_RpcMempoolEntry {
        get {return _entry ?? Protowire_RpcMempoolEntry()}
        set {_entry = newValue}
    }
    /// Returns true if `entry` has been explicitly set.
    public var hasEntry: Bool {return self._entry != nil}
    /// Clears the value of `entry`. Subsequent reads from it will return its default value.
    public mutating func clearEntry() {self._entry = nil}
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _entry: Protowire_RpcMempoolEntry? = nil
    fileprivate var _error: Protowire_RPCError? = nil
}

/// GetMempoolEntriesRequestMessage requests information about all the transactions
/// currently in the mempool.
public struct Protowire_GetMempoolEntriesRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var includeOrphanPool: Bool = false
    
    public var filterTransactionPool: Bool = false
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetMempoolEntriesResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var entries: [Protowire_RpcMempoolEntry] = []
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_RpcMempoolEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var fee: UInt64 = 0
    
    public var transaction: Protowire_RpcTransaction {
        get {return _transaction ?? Protowire_RpcTransaction()}
        set {_transaction = newValue}
    }
    /// Returns true if `transaction` has been explicitly set.
    public var hasTransaction: Bool {return self._transaction != nil}
    /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
    public mutating func clearTransaction() {self._transaction = nil}
    
    public var isOrphan: Bool = false
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _transaction: Protowire_RpcTransaction? = nil
}

/// GetConnectedPeerInfoRequestMessage requests information about all the p2p peers
/// currently connected to this kaspad.
public struct Protowire_GetConnectedPeerInfoRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetConnectedPeerInfoResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var infos: [Protowire_GetConnectedPeerInfoMessage] = []
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_GetConnectedPeerInfoMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var id: String = String()
    
    public var address: String = String()
    
    /// How long did the last ping/pong exchange take
    public var lastPingDuration: Int64 = 0
    
    /// Whether this kaspad initiated the connection
    public var isOutbound: Bool = false
    
    public var timeOffset: Int64 = 0
    
    public var userAgent: String = String()
    
    /// The protocol version that this peer claims to support
    public var advertisedProtocolVersion: UInt32 = 0
    
    /// The timestamp of when this peer connected to this kaspad
    public var timeConnected: Int64 = 0
    
    /// Whether this peer is the IBD peer (if IBD is running)
    public var isIbdPeer: Bool = false
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

/// AddPeerRequestMessage adds a peer to kaspad's outgoing connection list.
/// This will, in most cases, result in kaspad connecting to said peer.
public struct Protowire_AddPeerRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var address: String = String()
    
    /// Whether to keep attempting to connect to this peer after disconnection
    public var isPermanent: Bool = false
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_AddPeerResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// SubmitTransactionRequestMessage submits a transaction to the mempool
public struct Protowire_SubmitTransactionRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var transaction: Protowire_RpcTransaction {
        get {return _transaction ?? Protowire_RpcTransaction()}
        set {_transaction = newValue}
    }
    /// Returns true if `transaction` has been explicitly set.
    public var hasTransaction: Bool {return self._transaction != nil}
    /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
    public mutating func clearTransaction() {self._transaction = nil}
    
    public var allowOrphan: Bool = false
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _transaction: Protowire_RpcTransaction? = nil
}

public struct Protowire_SubmitTransactionResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    /// The transaction ID of the submitted transaction
    public var transactionID: String = String()
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// SubmitTransactionReplacementRequestMessage submits a transaction to the mempool, applying a mandatory Replace by Fee policy
public struct Protowire_SubmitTransactionReplacementRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var transaction: Protowire_RpcTransaction {
        get {return _transaction ?? Protowire_RpcTransaction()}
        set {_transaction = newValue}
    }
    /// Returns true if `transaction` has been explicitly set.
    public var hasTransaction: Bool {return self._transaction != nil}
    /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
    public mutating func clearTransaction() {self._transaction = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _transaction: Protowire_RpcTransaction? = nil
}

public struct Protowire_SubmitTransactionReplacementResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    /// The transaction ID of the submitted transaction
    public var transactionID: String = String()
    
    /// The previous transaction replaced in the mempool by the newly submitted one
    public var replacedTransaction: Protowire_RpcTransaction {
        get {return _replacedTransaction ?? Protowire_RpcTransaction()}
        set {_replacedTransaction = newValue}
    }
    /// Returns true if `replacedTransaction` has been explicitly set.
    public var hasReplacedTransaction: Bool {return self._replacedTransaction != nil}
    /// Clears the value of `replacedTransaction`. Subsequent reads from it will return its default value.
    public mutating func clearReplacedTransaction() {self._replacedTransaction = nil}
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _replacedTransaction: Protowire_RpcTransaction? = nil
    fileprivate var _error: Protowire_RPCError? = nil
}

/// NotifyVirtualChainChangedRequestMessage registers this connection for virtualChainChanged notifications.
///
/// See: VirtualChainChangedNotificationMessage
public struct Protowire_NotifyVirtualChainChangedRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var includeAcceptedTransactionIds: Bool = false
    
    public var command: Protowire_RpcNotifyCommand = .notifyStart
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_NotifyVirtualChainChangedResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// VirtualChainChangedNotificationMessage is sent whenever the DAG's selected parent
/// chain had changed.
///
/// See: NotifyVirtualChainChangedRequestMessage
public struct Protowire_VirtualChainChangedNotificationMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    /// The chain blocks that were removed, in high-to-low order
    public var removedChainBlockHashes: [String] = []
    
    /// The chain blocks that were added, in low-to-high order
    public var addedChainBlockHashes: [String] = []
    
    /// Will be filled only if `includeAcceptedTransactionIds = true` in the notify request.
    public var acceptedTransactionIds: [Protowire_RpcAcceptedTransactionIds] = []
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

/// GetBlockRequestMessage requests information about a specific block
public struct Protowire_GetBlockRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    /// The hash of the requested block
    public var hash: String = String()
    
    /// Whether to include transaction data in the response
    public var includeTransactions: Bool = false
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetBlockResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var block: Protowire_RpcBlock {
        get {return _block ?? Protowire_RpcBlock()}
        set {_block = newValue}
    }
    /// Returns true if `block` has been explicitly set.
    public var hasBlock: Bool {return self._block != nil}
    /// Clears the value of `block`. Subsequent reads from it will return its default value.
    public mutating func clearBlock() {self._block = nil}
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _block: Protowire_RpcBlock? = nil
    fileprivate var _error: Protowire_RPCError? = nil
}

/// GetSubnetworkRequestMessage requests information about a specific subnetwork
///
/// Currently unimplemented
public struct Protowire_GetSubnetworkRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var subnetworkID: String = String()
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetSubnetworkResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var gasLimit: UInt64 = 0
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// GetVirtualChainFromBlockRequestMessage requests the virtual selected
/// parent chain from some startHash to this kaspad's current virtual
public struct Protowire_GetVirtualChainFromBlockRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var startHash: String = String()
    
    public var includeAcceptedTransactionIds: Bool = false
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_RpcAcceptedTransactionIds: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var acceptingBlockHash: String = String()
    
    public var acceptedTransactionIds: [String] = []
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetVirtualChainFromBlockResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    /// The chain blocks that were removed, in high-to-low order
    public var removedChainBlockHashes: [String] = []
    
    /// The chain blocks that were added, in low-to-high order
    public var addedChainBlockHashes: [String] = []
    
    /// The transactions accepted by each block in addedChainBlockHashes.
    /// Will be filled only if `includeAcceptedTransactionIds = true` in the request.
    public var acceptedTransactionIds: [Protowire_RpcAcceptedTransactionIds] = []
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// GetBlocksRequestMessage requests blocks between a certain block lowHash up to this
/// kaspad's current virtual.
public struct Protowire_GetBlocksRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var lowHash: String = String()
    
    public var includeBlocks: Bool = false
    
    public var includeTransactions: Bool = false
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetBlocksResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var blockHashes: [String] = []
    
    public var blocks: [Protowire_RpcBlock] = []
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// GetBlockCountRequestMessage requests the current number of blocks in this kaspad.
/// Note that this number may decrease as pruning occurs.
public struct Protowire_GetBlockCountRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetBlockCountResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var blockCount: UInt64 = 0
    
    public var headerCount: UInt64 = 0
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// GetBlockDagInfoRequestMessage requests general information about the current state
/// of this kaspad's DAG.
public struct Protowire_GetBlockDagInfoRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetBlockDagInfoResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var networkName: String = String()
    
    public var blockCount: UInt64 = 0
    
    public var headerCount: UInt64 = 0
    
    public var tipHashes: [String] = []
    
    public var difficulty: Double = 0
    
    public var pastMedianTime: Int64 = 0
    
    public var virtualParentHashes: [String] = []
    
    public var pruningPointHash: String = String()
    
    public var virtualDaaScore: UInt64 = 0
    
    public var sink: String = String()
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_ResolveFinalityConflictRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var finalityBlockHash: String = String()
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_ResolveFinalityConflictResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_NotifyFinalityConflictRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var command: Protowire_RpcNotifyCommand = .notifyStart
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_NotifyFinalityConflictResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_FinalityConflictNotificationMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var violatingBlockHash: String = String()
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_FinalityConflictResolvedNotificationMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var finalityBlockHash: String = String()
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

/// ShutdownRequestMessage shuts down this kaspad.
public struct Protowire_ShutdownRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_ShutdownResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// GetHeadersRequestMessage requests headers between the given startHash and the
/// current virtual, up to the given limit.
public struct Protowire_GetHeadersRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var startHash: String = String()
    
    public var limit: UInt64 = 0
    
    public var isAscending: Bool = false
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetHeadersResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var headers: [String] = []
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// NotifyUtxosChangedRequestMessage registers this connection for utxoChanged notifications
/// for the given addresses.
///
/// This call is only available when this kaspad was started with `--utxoindex`
///
/// See: UtxosChangedNotificationMessage
public struct Protowire_NotifyUtxosChangedRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    /// UTXOs addresses to start/stop getting notified about
    /// Leave empty to start/stop all updates
    public var addresses: [String] = []
    
    public var command: Protowire_RpcNotifyCommand = .notifyStart
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_NotifyUtxosChangedResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// UtxosChangedNotificationMessage is sent whenever the UTXO index had been updated.
///
/// See: NotifyUtxosChangedRequestMessage
public struct Protowire_UtxosChangedNotificationMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var added: [Protowire_RpcUtxosByAddressesEntry] = []
    
    public var removed: [Protowire_RpcUtxosByAddressesEntry] = []
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_RpcUtxosByAddressesEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var address: String = String()
    
    public var outpoint: Protowire_RpcOutpoint {
        get {return _outpoint ?? Protowire_RpcOutpoint()}
        set {_outpoint = newValue}
    }
    /// Returns true if `outpoint` has been explicitly set.
    public var hasOutpoint: Bool {return self._outpoint != nil}
    /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
    public mutating func clearOutpoint() {self._outpoint = nil}
    
    public var utxoEntry: Protowire_RpcUtxoEntry {
        get {return _utxoEntry ?? Protowire_RpcUtxoEntry()}
        set {_utxoEntry = newValue}
    }
    /// Returns true if `utxoEntry` has been explicitly set.
    public var hasUtxoEntry: Bool {return self._utxoEntry != nil}
    /// Clears the value of `utxoEntry`. Subsequent reads from it will return its default value.
    public mutating func clearUtxoEntry() {self._utxoEntry = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _outpoint: Protowire_RpcOutpoint? = nil
    fileprivate var _utxoEntry: Protowire_RpcUtxoEntry? = nil
}

/// StopNotifyingUtxosChangedRequestMessage unregisters this connection for utxoChanged notifications
/// for the given addresses.
///
/// This call is only available when this kaspad was started with `--utxoindex`
///
/// See: UtxosChangedNotificationMessage
///
/// This message only exists for backward compatibility reason with kaspad and is deprecated.
/// Use instead UtxosChangedNotificationMessage with command = NOTIFY_STOP.
public struct Protowire_StopNotifyingUtxosChangedRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var addresses: [String] = []
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_StopNotifyingUtxosChangedResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// GetUtxosByAddressesRequestMessage requests all current UTXOs for the given kaspad addresses
///
/// This call is only available when this kaspad was started with `--utxoindex`
public struct Protowire_GetUtxosByAddressesRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var addresses: [String] = []
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetUtxosByAddressesResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var entries: [Protowire_RpcUtxosByAddressesEntry] = []
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// GetBalanceByAddressRequest returns the total balance in unspent transactions towards a given address
///
/// This call is only available when this kaspad was started with `--utxoindex`
public struct Protowire_GetBalanceByAddressRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var address: String = String()
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetBalanceByAddressResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var balance: UInt64 = 0
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_GetBalancesByAddressesRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var addresses: [String] = []
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_RpcBalancesByAddressesEntry: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var address: String = String()
    
    public var balance: UInt64 = 0
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_GetBalancesByAddressesResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var entries: [Protowire_RpcBalancesByAddressesEntry] = []
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// GetSinkBlueScoreRequestMessage requests the blue score of the current selected parent
/// of the virtual block.
public struct Protowire_GetSinkBlueScoreRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetSinkBlueScoreResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var blueScore: UInt64 = 0
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// NotifySinkBlueScoreChangedRequestMessage registers this connection for
/// sinkBlueScoreChanged notifications.
///
/// See: SinkBlueScoreChangedNotificationMessage
public struct Protowire_NotifySinkBlueScoreChangedRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var command: Protowire_RpcNotifyCommand = .notifyStart
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_NotifySinkBlueScoreChangedResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// SinkBlueScoreChangedNotificationMessage is sent whenever the blue score
/// of the virtual's selected parent changes.
///
/// See NotifySinkBlueScoreChangedRequestMessage
public struct Protowire_SinkBlueScoreChangedNotificationMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var sinkBlueScore: UInt64 = 0
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

/// NotifyVirtualDaaScoreChangedRequestMessage registers this connection for
/// virtualDaaScoreChanged notifications.
///
/// See: VirtualDaaScoreChangedNotificationMessage
public struct Protowire_NotifyVirtualDaaScoreChangedRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var command: Protowire_RpcNotifyCommand = .notifyStart
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_NotifyVirtualDaaScoreChangedResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// VirtualDaaScoreChangedNotificationMessage is sent whenever the DAA score
/// of the virtual changes.
///
/// See NotifyVirtualDaaScoreChangedRequestMessage
public struct Protowire_VirtualDaaScoreChangedNotificationMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var virtualDaaScore: UInt64 = 0
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

/// NotifyPruningPointUtxoSetOverrideRequestMessage registers this connection for
/// pruning point UTXO set override notifications.
///
/// This call is only available when this kaspad was started with `--utxoindex`
///
/// See: NotifyPruningPointUtxoSetOverrideResponseMessage
public struct Protowire_NotifyPruningPointUtxoSetOverrideRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var command: Protowire_RpcNotifyCommand = .notifyStart
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_NotifyPruningPointUtxoSetOverrideResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// PruningPointUtxoSetOverrideNotificationMessage is sent whenever the UTXO index
/// resets due to pruning point change via IBD.
///
/// See NotifyPruningPointUtxoSetOverrideRequestMessage
public struct Protowire_PruningPointUtxoSetOverrideNotificationMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

/// StopNotifyingPruningPointUtxoSetOverrideRequestMessage unregisters this connection for
/// pruning point UTXO set override notifications.
///
/// This call is only available when this kaspad was started with `--utxoindex`
///
/// See: PruningPointUtxoSetOverrideNotificationMessage
///
/// This message only exists for backward compatibility reason with kaspad and is deprecated.
/// Use instead NotifyPruningPointUtxoSetOverrideRequestMessage with command = NOTIFY_STOP.
public struct Protowire_StopNotifyingPruningPointUtxoSetOverrideRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_StopNotifyingPruningPointUtxoSetOverrideResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// BanRequestMessage bans the given ip.
public struct Protowire_BanRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var ip: String = String()
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_BanResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// UnbanRequestMessage unbans the given ip.
public struct Protowire_UnbanRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var ip: String = String()
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_UnbanResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// GetInfoRequestMessage returns info about the node.
public struct Protowire_GetInfoRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetInfoResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var p2PID: String = String()
    
    public var mempoolSize: UInt64 = 0
    
    public var serverVersion: String = String()
    
    public var isUtxoIndexed: Bool = false
    
    public var isSynced: Bool = false
    
    public var hasNotifyCommand_p: Bool = false
    
    public var hasMessageID_p: Bool = false
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_EstimateNetworkHashesPerSecondRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var windowSize: UInt32 = 0
    
    public var startHash: String = String()
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_EstimateNetworkHashesPerSecondResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var networkHashesPerSecond: UInt64 = 0
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// NotifyNewBlockTemplateRequestMessage registers this connection for
/// NewBlockTemplate notifications.
///
/// See: NewBlockTemplateNotificationMessage
public struct Protowire_NotifyNewBlockTemplateRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var command: Protowire_RpcNotifyCommand = .notifyStart
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_NotifyNewBlockTemplateResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

/// NewBlockTemplateNotificationMessage is sent whenever a new updated block template is
/// available for miners.
///
/// See NotifyNewBlockTemplateRequestMessage
public struct Protowire_NewBlockTemplateNotificationMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_RpcMempoolEntryByAddress: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var address: String = String()
    
    public var sending: [Protowire_RpcMempoolEntry] = []
    
    public var receiving: [Protowire_RpcMempoolEntry] = []
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetMempoolEntriesByAddressesRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var addresses: [String] = []
    
    public var includeOrphanPool: Bool = false
    
    public var filterTransactionPool: Bool = false
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetMempoolEntriesByAddressesResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var entries: [Protowire_RpcMempoolEntryByAddress] = []
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_GetCoinSupplyRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetCoinSupplyResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    /// note: this is a hard coded maxSupply, actual maxSupply is expected to deviate by upto -5%, but cannot be measured exactly.
    public var maxSompi: UInt64 = 0
    
    public var circulatingSompi: UInt64 = 0
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_PingRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_PingResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_ProcessMetrics: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var residentSetSize: UInt64 = 0
    
    public var virtualMemorySize: UInt64 = 0
    
    public var coreNum: UInt32 = 0
    
    public var cpuUsage: Float = 0
    
    public var fdNum: UInt32 = 0
    
    public var diskIoReadBytes: UInt64 = 0
    
    public var diskIoWriteBytes: UInt64 = 0
    
    public var diskIoReadPerSec: Float = 0
    
    public var diskIoWritePerSec: Float = 0
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_ConnectionMetrics: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var borshLiveConnections: UInt32 = 0
    
    public var borshConnectionAttempts: UInt64 = 0
    
    public var borshHandshakeFailures: UInt64 = 0
    
    public var jsonLiveConnections: UInt32 = 0
    
    public var jsonConnectionAttempts: UInt64 = 0
    
    public var jsonHandshakeFailures: UInt64 = 0
    
    public var activePeers: UInt32 = 0
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_BandwidthMetrics: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var borshBytesTx: UInt64 = 0
    
    public var borshBytesRx: UInt64 = 0
    
    public var jsonBytesTx: UInt64 = 0
    
    public var jsonBytesRx: UInt64 = 0
    
    public var grpcP2PBytesTx: UInt64 = 0
    
    public var grpcP2PBytesRx: UInt64 = 0
    
    public var grpcUserBytesTx: UInt64 = 0
    
    public var grpcUserBytesRx: UInt64 = 0
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_ConsensusMetrics: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var blocksSubmitted: UInt64 = 0
    
    public var headerCounts: UInt64 = 0
    
    public var depCounts: UInt64 = 0
    
    public var bodyCounts: UInt64 = 0
    
    public var txsCounts: UInt64 = 0
    
    public var chainBlockCounts: UInt64 = 0
    
    public var massCounts: UInt64 = 0
    
    public var blockCount: UInt64 = 0
    
    public var headerCount: UInt64 = 0
    
    public var mempoolSize: UInt64 = 0
    
    public var tipHashesCount: UInt32 = 0
    
    public var difficulty: Double = 0
    
    public var pastMedianTime: UInt64 = 0
    
    public var virtualParentHashesCount: UInt32 = 0
    
    public var virtualDaaScore: UInt64 = 0
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_StorageMetrics: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var storageSizeBytes: UInt64 = 0
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetConnectionsRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var includeProfileData: Bool = false
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_ConnectionsProfileData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var cpuUsage: Double = 0
    
    public var memoryUsage: UInt64 = 0
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetConnectionsResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var clients: UInt32 = 0
    
    public var peers: UInt32 = 0
    
    public var profileData: Protowire_ConnectionsProfileData {
        get {return _profileData ?? Protowire_ConnectionsProfileData()}
        set {_profileData = newValue}
    }
    /// Returns true if `profileData` has been explicitly set.
    public var hasProfileData: Bool {return self._profileData != nil}
    /// Clears the value of `profileData`. Subsequent reads from it will return its default value.
    public mutating func clearProfileData() {self._profileData = nil}
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _profileData: Protowire_ConnectionsProfileData? = nil
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_GetSystemInfoRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetSystemInfoResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var version: String = String()
    
    public var systemID: String = String()
    
    public var gitHash: String = String()
    
    public var coreNum: UInt32 = 0
    
    public var totalMemory: UInt64 = 0
    
    public var fdLimit: UInt32 = 0
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_GetMetricsRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var processMetrics: Bool = false
    
    public var connectionMetrics: Bool = false
    
    public var bandwidthMetrics: Bool = false
    
    public var consensusMetrics: Bool = false
    
    public var storageMetrics: Bool = false
    
    public var customMetrics: Bool = false
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetMetricsResponseMessage: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var serverTime: UInt64 {
        get {return _storage._serverTime}
        set {_uniqueStorage()._serverTime = newValue}
    }
    
    public var processMetrics: Protowire_ProcessMetrics {
        get {return _storage._processMetrics ?? Protowire_ProcessMetrics()}
        set {_uniqueStorage()._processMetrics = newValue}
    }
    /// Returns true if `processMetrics` has been explicitly set.
    public var hasProcessMetrics: Bool {return _storage._processMetrics != nil}
    /// Clears the value of `processMetrics`. Subsequent reads from it will return its default value.
    public mutating func clearProcessMetrics() {_uniqueStorage()._processMetrics = nil}
    
    public var connectionMetrics: Protowire_ConnectionMetrics {
        get {return _storage._connectionMetrics ?? Protowire_ConnectionMetrics()}
        set {_uniqueStorage()._connectionMetrics = newValue}
    }
    /// Returns true if `connectionMetrics` has been explicitly set.
    public var hasConnectionMetrics: Bool {return _storage._connectionMetrics != nil}
    /// Clears the value of `connectionMetrics`. Subsequent reads from it will return its default value.
    public mutating func clearConnectionMetrics() {_uniqueStorage()._connectionMetrics = nil}
    
    public var bandwidthMetrics: Protowire_BandwidthMetrics {
        get {return _storage._bandwidthMetrics ?? Protowire_BandwidthMetrics()}
        set {_uniqueStorage()._bandwidthMetrics = newValue}
    }
    /// Returns true if `bandwidthMetrics` has been explicitly set.
    public var hasBandwidthMetrics: Bool {return _storage._bandwidthMetrics != nil}
    /// Clears the value of `bandwidthMetrics`. Subsequent reads from it will return its default value.
    public mutating func clearBandwidthMetrics() {_uniqueStorage()._bandwidthMetrics = nil}
    
    public var consensusMetrics: Protowire_ConsensusMetrics {
        get {return _storage._consensusMetrics ?? Protowire_ConsensusMetrics()}
        set {_uniqueStorage()._consensusMetrics = newValue}
    }
    /// Returns true if `consensusMetrics` has been explicitly set.
    public var hasConsensusMetrics: Bool {return _storage._consensusMetrics != nil}
    /// Clears the value of `consensusMetrics`. Subsequent reads from it will return its default value.
    public mutating func clearConsensusMetrics() {_uniqueStorage()._consensusMetrics = nil}
    
    public var storageMetrics: Protowire_StorageMetrics {
        get {return _storage._storageMetrics ?? Protowire_StorageMetrics()}
        set {_uniqueStorage()._storageMetrics = newValue}
    }
    /// Returns true if `storageMetrics` has been explicitly set.
    public var hasStorageMetrics: Bool {return _storage._storageMetrics != nil}
    /// Clears the value of `storageMetrics`. Subsequent reads from it will return its default value.
    public mutating func clearStorageMetrics() {_uniqueStorage()._storageMetrics = nil}
    
    public var error: Protowire_RPCError {
        get {return _storage._error ?? Protowire_RPCError()}
        set {_uniqueStorage()._error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return _storage._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {_uniqueStorage()._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Protowire_GetServerInfoRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetServerInfoResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var rpcApiVersion: UInt32 = 0
    
    public var rpcApiRevision: UInt32 = 0
    
    public var serverVersion: String = String()
    
    public var networkID: String = String()
    
    public var hasUtxoIndex_p: Bool = false
    
    public var isSynced: Bool = false
    
    public var virtualDaaScore: UInt64 = 0
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_GetSyncStatusRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetSyncStatusResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var isSynced: Bool = false
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_GetDaaScoreTimestampEstimateRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var daaScores: [UInt64] = []
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetDaaScoreTimestampEstimateResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var timestamps: [UInt64] = []
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_RpcFeerateBucket: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    /// Fee/mass of a transaction in `sompi/gram` units
    public var feerate: Double = 0
    
    public var estimatedSeconds: Double = 0
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

/// Data required for making fee estimates.
///
/// Feerate values represent fee/mass of a transaction in `sompi/gram` units.
/// Given a feerate value recommendation, calculate the required fee by
/// taking the transaction mass and multiplying it by feerate: `fee = feerate * mass(tx)`
public struct Protowire_RpcFeeEstimate: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    /// Top-priority feerate bucket. Provides an estimation of the feerate required for sub-second DAG inclusion.
    public var priorityBucket: Protowire_RpcFeerateBucket {
        get {return _priorityBucket ?? Protowire_RpcFeerateBucket()}
        set {_priorityBucket = newValue}
    }
    /// Returns true if `priorityBucket` has been explicitly set.
    public var hasPriorityBucket: Bool {return self._priorityBucket != nil}
    /// Clears the value of `priorityBucket`. Subsequent reads from it will return its default value.
    public mutating func clearPriorityBucket() {self._priorityBucket = nil}
    
    /// A vector of *normal* priority feerate values. The first value of this vector is guaranteed to exist and
    /// provide an estimation for sub-*minute* DAG inclusion. All other values will have shorter estimation
    /// times than all `low_bucket` values. Therefor by chaining `[priority] | normal | low` and interpolating
    /// between them, one can compose a complete feerate public function on the client side. The API makes an effort
    /// to sample enough "interesting" points on the feerate-to-time curve, so that the interpolation is meaningful.
    public var normalBuckets: [Protowire_RpcFeerateBucket] = []
    
    /// A vector of *low* priority feerate values. The first value of this vector is guaranteed to
    /// exist and provide an estimation for sub-*hour* DAG inclusion.
    public var lowBuckets: [Protowire_RpcFeerateBucket] = []
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _priorityBucket: Protowire_RpcFeerateBucket? = nil
}

public struct Protowire_RpcFeeEstimateVerboseExperimentalData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var mempoolReadyTransactionsCount: UInt64 = 0
    
    public var mempoolReadyTransactionsTotalMass: UInt64 = 0
    
    public var networkMassPerSecond: UInt64 = 0
    
    public var nextBlockTemplateFeerateMin: Double = 0
    
    public var nextBlockTemplateFeerateMedian: Double = 0
    
    public var nextBlockTemplateFeerateMax: Double = 0
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetFeeEstimateRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetFeeEstimateResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var estimate: Protowire_RpcFeeEstimate {
        get {return _estimate ?? Protowire_RpcFeeEstimate()}
        set {_estimate = newValue}
    }
    /// Returns true if `estimate` has been explicitly set.
    public var hasEstimate: Bool {return self._estimate != nil}
    /// Clears the value of `estimate`. Subsequent reads from it will return its default value.
    public mutating func clearEstimate() {self._estimate = nil}
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _estimate: Protowire_RpcFeeEstimate? = nil
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_GetFeeEstimateExperimentalRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var verbose: Bool = false
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetFeeEstimateExperimentalResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var estimate: Protowire_RpcFeeEstimate {
        get {return _estimate ?? Protowire_RpcFeeEstimate()}
        set {_estimate = newValue}
    }
    /// Returns true if `estimate` has been explicitly set.
    public var hasEstimate: Bool {return self._estimate != nil}
    /// Clears the value of `estimate`. Subsequent reads from it will return its default value.
    public mutating func clearEstimate() {self._estimate = nil}
    
    public var verbose: Protowire_RpcFeeEstimateVerboseExperimentalData {
        get {return _verbose ?? Protowire_RpcFeeEstimateVerboseExperimentalData()}
        set {_verbose = newValue}
    }
    /// Returns true if `verbose` has been explicitly set.
    public var hasVerbose: Bool {return self._verbose != nil}
    /// Clears the value of `verbose`. Subsequent reads from it will return its default value.
    public mutating func clearVerbose() {self._verbose = nil}
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _estimate: Protowire_RpcFeeEstimate? = nil
    fileprivate var _verbose: Protowire_RpcFeeEstimateVerboseExperimentalData? = nil
    fileprivate var _error: Protowire_RPCError? = nil
}

public struct Protowire_GetCurrentBlockColorRequestMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var hash: String = String()
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
}

public struct Protowire_GetCurrentBlockColorResponseMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.
    
    public var blue: Bool = false
    
    public var error: Protowire_RPCError {
        get {return _error ?? Protowire_RPCError()}
        set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}
    
    public var unknownFields = SwiftProtobuf.UnknownStorage()
    
    public init() {}
    
    fileprivate var _error: Protowire_RPCError? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protowire"

extension Protowire_RpcNotifyCommand: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "NOTIFY_START"),
        1: .same(proto: "NOTIFY_STOP"),
    ]
}

extension Protowire_RPCError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RPCError"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "message"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.message.isEmpty {
            try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_RPCError, rhs: Protowire_RPCError) -> Bool {
        if lhs.message != rhs.message {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcBlock"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "header"),
        2: .same(proto: "transactions"),
        3: .same(proto: "verboseData"),
    ]
    
    public class _StorageClass {
        public var _header: Protowire_RpcBlockHeader? = nil
        public var _transactions: [Protowire_RpcTransaction] = []
        public var _verboseData: Protowire_RpcBlockVerboseData? = nil
        
#if swift(>=5.10)
        // This property is used as the initial default value for new instances of the type.
        // The type itself is protecting the reference to its storage via CoW semantics.
        // This will force a copy to be made of this reference when the first mutation occurs;
        // hence, it is safe to mark this as `nonisolated(unsafe)`.
        static nonisolated(unsafe) let defaultInstance = _StorageClass()
#else
        public static let defaultInstance = _StorageClass()
#endif
        
        public init() {}
        
        init(copying source: _StorageClass) {
            _header = source._header
            _transactions = source._transactions
            _verboseData = source._verboseData
        }
    }
    
    public mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
                case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._transactions) }()
                case 3: try { try decoder.decodeSingularMessageField(value: &_storage._verboseData) }()
                default: break
                }
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            try { if let v = _storage._header {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            } }()
            if !_storage._transactions.isEmpty {
                try visitor.visitRepeatedMessageField(value: _storage._transactions, fieldNumber: 2)
            }
            try { if let v = _storage._verboseData {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            } }()
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_RpcBlock, rhs: Protowire_RpcBlock) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._header != rhs_storage._header {return false}
                if _storage._transactions != rhs_storage._transactions {return false}
                if _storage._verboseData != rhs_storage._verboseData {return false}
                return true
            }
            if !storagesAreEqual {return false}
        }
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcBlockHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcBlockHeader"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "version"),
        12: .same(proto: "parents"),
        3: .same(proto: "hashMerkleRoot"),
        4: .same(proto: "acceptedIdMerkleRoot"),
        5: .same(proto: "utxoCommitment"),
        6: .same(proto: "timestamp"),
        7: .same(proto: "bits"),
        8: .same(proto: "nonce"),
        9: .same(proto: "daaScore"),
        10: .same(proto: "blueWork"),
        14: .same(proto: "pruningPoint"),
        13: .same(proto: "blueScore"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.hashMerkleRoot) }()
            case 4: try { try decoder.decodeSingularStringField(value: &self.acceptedIDMerkleRoot) }()
            case 5: try { try decoder.decodeSingularStringField(value: &self.utxoCommitment) }()
            case 6: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
            case 7: try { try decoder.decodeSingularUInt32Field(value: &self.bits) }()
            case 8: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
            case 9: try { try decoder.decodeSingularUInt64Field(value: &self.daaScore) }()
            case 10: try { try decoder.decodeSingularStringField(value: &self.blueWork) }()
            case 12: try { try decoder.decodeRepeatedMessageField(value: &self.parents) }()
            case 13: try { try decoder.decodeSingularUInt64Field(value: &self.blueScore) }()
            case 14: try { try decoder.decodeSingularStringField(value: &self.pruningPoint) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.version != 0 {
            try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 1)
        }
        if !self.hashMerkleRoot.isEmpty {
            try visitor.visitSingularStringField(value: self.hashMerkleRoot, fieldNumber: 3)
        }
        if !self.acceptedIDMerkleRoot.isEmpty {
            try visitor.visitSingularStringField(value: self.acceptedIDMerkleRoot, fieldNumber: 4)
        }
        if !self.utxoCommitment.isEmpty {
            try visitor.visitSingularStringField(value: self.utxoCommitment, fieldNumber: 5)
        }
        if self.timestamp != 0 {
            try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 6)
        }
        if self.bits != 0 {
            try visitor.visitSingularUInt32Field(value: self.bits, fieldNumber: 7)
        }
        if self.nonce != 0 {
            try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 8)
        }
        if self.daaScore != 0 {
            try visitor.visitSingularUInt64Field(value: self.daaScore, fieldNumber: 9)
        }
        if !self.blueWork.isEmpty {
            try visitor.visitSingularStringField(value: self.blueWork, fieldNumber: 10)
        }
        if !self.parents.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.parents, fieldNumber: 12)
        }
        if self.blueScore != 0 {
            try visitor.visitSingularUInt64Field(value: self.blueScore, fieldNumber: 13)
        }
        if !self.pruningPoint.isEmpty {
            try visitor.visitSingularStringField(value: self.pruningPoint, fieldNumber: 14)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_RpcBlockHeader, rhs: Protowire_RpcBlockHeader) -> Bool {
        if lhs.version != rhs.version {return false}
        if lhs.parents != rhs.parents {return false}
        if lhs.hashMerkleRoot != rhs.hashMerkleRoot {return false}
        if lhs.acceptedIDMerkleRoot != rhs.acceptedIDMerkleRoot {return false}
        if lhs.utxoCommitment != rhs.utxoCommitment {return false}
        if lhs.timestamp != rhs.timestamp {return false}
        if lhs.bits != rhs.bits {return false}
        if lhs.nonce != rhs.nonce {return false}
        if lhs.daaScore != rhs.daaScore {return false}
        if lhs.blueWork != rhs.blueWork {return false}
        if lhs.pruningPoint != rhs.pruningPoint {return false}
        if lhs.blueScore != rhs.blueScore {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcBlockLevelParents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcBlockLevelParents"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "parentHashes"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedStringField(value: &self.parentHashes) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.parentHashes.isEmpty {
            try visitor.visitRepeatedStringField(value: self.parentHashes, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_RpcBlockLevelParents, rhs: Protowire_RpcBlockLevelParents) -> Bool {
        if lhs.parentHashes != rhs.parentHashes {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcBlockVerboseData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcBlockVerboseData"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "hash"),
        11: .same(proto: "difficulty"),
        13: .same(proto: "selectedParentHash"),
        14: .same(proto: "transactionIds"),
        15: .same(proto: "isHeaderOnly"),
        16: .same(proto: "blueScore"),
        17: .same(proto: "childrenHashes"),
        18: .same(proto: "mergeSetBluesHashes"),
        19: .same(proto: "mergeSetRedsHashes"),
        20: .same(proto: "isChainBlock"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
            case 11: try { try decoder.decodeSingularDoubleField(value: &self.difficulty) }()
            case 13: try { try decoder.decodeSingularStringField(value: &self.selectedParentHash) }()
            case 14: try { try decoder.decodeRepeatedStringField(value: &self.transactionIds) }()
            case 15: try { try decoder.decodeSingularBoolField(value: &self.isHeaderOnly) }()
            case 16: try { try decoder.decodeSingularUInt64Field(value: &self.blueScore) }()
            case 17: try { try decoder.decodeRepeatedStringField(value: &self.childrenHashes) }()
            case 18: try { try decoder.decodeRepeatedStringField(value: &self.mergeSetBluesHashes) }()
            case 19: try { try decoder.decodeRepeatedStringField(value: &self.mergeSetRedsHashes) }()
            case 20: try { try decoder.decodeSingularBoolField(value: &self.isChainBlock) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.hash.isEmpty {
            try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
        }
        if self.difficulty.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: self.difficulty, fieldNumber: 11)
        }
        if !self.selectedParentHash.isEmpty {
            try visitor.visitSingularStringField(value: self.selectedParentHash, fieldNumber: 13)
        }
        if !self.transactionIds.isEmpty {
            try visitor.visitRepeatedStringField(value: self.transactionIds, fieldNumber: 14)
        }
        if self.isHeaderOnly != false {
            try visitor.visitSingularBoolField(value: self.isHeaderOnly, fieldNumber: 15)
        }
        if self.blueScore != 0 {
            try visitor.visitSingularUInt64Field(value: self.blueScore, fieldNumber: 16)
        }
        if !self.childrenHashes.isEmpty {
            try visitor.visitRepeatedStringField(value: self.childrenHashes, fieldNumber: 17)
        }
        if !self.mergeSetBluesHashes.isEmpty {
            try visitor.visitRepeatedStringField(value: self.mergeSetBluesHashes, fieldNumber: 18)
        }
        if !self.mergeSetRedsHashes.isEmpty {
            try visitor.visitRepeatedStringField(value: self.mergeSetRedsHashes, fieldNumber: 19)
        }
        if self.isChainBlock != false {
            try visitor.visitSingularBoolField(value: self.isChainBlock, fieldNumber: 20)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_RpcBlockVerboseData, rhs: Protowire_RpcBlockVerboseData) -> Bool {
        if lhs.hash != rhs.hash {return false}
        if lhs.difficulty != rhs.difficulty {return false}
        if lhs.selectedParentHash != rhs.selectedParentHash {return false}
        if lhs.transactionIds != rhs.transactionIds {return false}
        if lhs.isHeaderOnly != rhs.isHeaderOnly {return false}
        if lhs.blueScore != rhs.blueScore {return false}
        if lhs.childrenHashes != rhs.childrenHashes {return false}
        if lhs.mergeSetBluesHashes != rhs.mergeSetBluesHashes {return false}
        if lhs.mergeSetRedsHashes != rhs.mergeSetRedsHashes {return false}
        if lhs.isChainBlock != rhs.isChainBlock {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcTransaction"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "version"),
        2: .same(proto: "inputs"),
        3: .same(proto: "outputs"),
        4: .same(proto: "lockTime"),
        5: .same(proto: "subnetworkId"),
        6: .same(proto: "gas"),
        8: .same(proto: "payload"),
        9: .same(proto: "verboseData"),
        10: .same(proto: "mass"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
            case 3: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
            case 4: try { try decoder.decodeSingularUInt64Field(value: &self.lockTime) }()
            case 5: try { try decoder.decodeSingularStringField(value: &self.subnetworkID) }()
            case 6: try { try decoder.decodeSingularUInt64Field(value: &self.gas) }()
            case 8: try { try decoder.decodeSingularStringField(value: &self.payload) }()
            case 9: try { try decoder.decodeSingularMessageField(value: &self._verboseData) }()
            case 10: try { try decoder.decodeSingularUInt64Field(value: &self.mass) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.version != 0 {
            try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 1)
        }
        if !self.inputs.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 2)
        }
        if !self.outputs.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 3)
        }
        if self.lockTime != 0 {
            try visitor.visitSingularUInt64Field(value: self.lockTime, fieldNumber: 4)
        }
        if !self.subnetworkID.isEmpty {
            try visitor.visitSingularStringField(value: self.subnetworkID, fieldNumber: 5)
        }
        if self.gas != 0 {
            try visitor.visitSingularUInt64Field(value: self.gas, fieldNumber: 6)
        }
        if !self.payload.isEmpty {
            try visitor.visitSingularStringField(value: self.payload, fieldNumber: 8)
        }
        try { if let v = self._verboseData {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
        } }()
        if self.mass != 0 {
            try visitor.visitSingularUInt64Field(value: self.mass, fieldNumber: 10)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_RpcTransaction, rhs: Protowire_RpcTransaction) -> Bool {
        if lhs.version != rhs.version {return false}
        if lhs.inputs != rhs.inputs {return false}
        if lhs.outputs != rhs.outputs {return false}
        if lhs.lockTime != rhs.lockTime {return false}
        if lhs.subnetworkID != rhs.subnetworkID {return false}
        if lhs.gas != rhs.gas {return false}
        if lhs.payload != rhs.payload {return false}
        if lhs._verboseData != rhs._verboseData {return false}
        if lhs.mass != rhs.mass {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcTransactionInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcTransactionInput"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "previousOutpoint"),
        2: .same(proto: "signatureScript"),
        3: .same(proto: "sequence"),
        5: .same(proto: "sigOpCount"),
        4: .same(proto: "verboseData"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._previousOutpoint) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.signatureScript) }()
            case 3: try { try decoder.decodeSingularUInt64Field(value: &self.sequence) }()
            case 4: try { try decoder.decodeSingularMessageField(value: &self._verboseData) }()
            case 5: try { try decoder.decodeSingularUInt32Field(value: &self.sigOpCount) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._previousOutpoint {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !self.signatureScript.isEmpty {
            try visitor.visitSingularStringField(value: self.signatureScript, fieldNumber: 2)
        }
        if self.sequence != 0 {
            try visitor.visitSingularUInt64Field(value: self.sequence, fieldNumber: 3)
        }
        try { if let v = self._verboseData {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        if self.sigOpCount != 0 {
            try visitor.visitSingularUInt32Field(value: self.sigOpCount, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_RpcTransactionInput, rhs: Protowire_RpcTransactionInput) -> Bool {
        if lhs._previousOutpoint != rhs._previousOutpoint {return false}
        if lhs.signatureScript != rhs.signatureScript {return false}
        if lhs.sequence != rhs.sequence {return false}
        if lhs.sigOpCount != rhs.sigOpCount {return false}
        if lhs._verboseData != rhs._verboseData {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcScriptPublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcScriptPublicKey"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "version"),
        2: .same(proto: "scriptPublicKey"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.scriptPublicKey) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.version != 0 {
            try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 1)
        }
        if !self.scriptPublicKey.isEmpty {
            try visitor.visitSingularStringField(value: self.scriptPublicKey, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_RpcScriptPublicKey, rhs: Protowire_RpcScriptPublicKey) -> Bool {
        if lhs.version != rhs.version {return false}
        if lhs.scriptPublicKey != rhs.scriptPublicKey {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcTransactionOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcTransactionOutput"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "amount"),
        2: .same(proto: "scriptPublicKey"),
        3: .same(proto: "verboseData"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._scriptPublicKey) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._verboseData) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.amount != 0 {
            try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 1)
        }
        try { if let v = self._scriptPublicKey {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._verboseData {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_RpcTransactionOutput, rhs: Protowire_RpcTransactionOutput) -> Bool {
        if lhs.amount != rhs.amount {return false}
        if lhs._scriptPublicKey != rhs._scriptPublicKey {return false}
        if lhs._verboseData != rhs._verboseData {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcOutpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcOutpoint"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "transactionId"),
        2: .same(proto: "index"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
            case 2: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.transactionID.isEmpty {
            try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
        }
        if self.index != 0 {
            try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_RpcOutpoint, rhs: Protowire_RpcOutpoint) -> Bool {
        if lhs.transactionID != rhs.transactionID {return false}
        if lhs.index != rhs.index {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcUtxoEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcUtxoEntry"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "amount"),
        2: .same(proto: "scriptPublicKey"),
        3: .same(proto: "blockDaaScore"),
        4: .same(proto: "isCoinbase"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._scriptPublicKey) }()
            case 3: try { try decoder.decodeSingularUInt64Field(value: &self.blockDaaScore) }()
            case 4: try { try decoder.decodeSingularBoolField(value: &self.isCoinbase) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.amount != 0 {
            try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 1)
        }
        try { if let v = self._scriptPublicKey {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if self.blockDaaScore != 0 {
            try visitor.visitSingularUInt64Field(value: self.blockDaaScore, fieldNumber: 3)
        }
        if self.isCoinbase != false {
            try visitor.visitSingularBoolField(value: self.isCoinbase, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_RpcUtxoEntry, rhs: Protowire_RpcUtxoEntry) -> Bool {
        if lhs.amount != rhs.amount {return false}
        if lhs._scriptPublicKey != rhs._scriptPublicKey {return false}
        if lhs.blockDaaScore != rhs.blockDaaScore {return false}
        if lhs.isCoinbase != rhs.isCoinbase {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcTransactionVerboseData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcTransactionVerboseData"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "transactionId"),
        2: .same(proto: "hash"),
        4: .same(proto: "mass"),
        12: .same(proto: "blockHash"),
        14: .same(proto: "blockTime"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.hash) }()
            case 4: try { try decoder.decodeSingularUInt64Field(value: &self.mass) }()
            case 12: try { try decoder.decodeSingularStringField(value: &self.blockHash) }()
            case 14: try { try decoder.decodeSingularUInt64Field(value: &self.blockTime) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.transactionID.isEmpty {
            try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
        }
        if !self.hash.isEmpty {
            try visitor.visitSingularStringField(value: self.hash, fieldNumber: 2)
        }
        if self.mass != 0 {
            try visitor.visitSingularUInt64Field(value: self.mass, fieldNumber: 4)
        }
        if !self.blockHash.isEmpty {
            try visitor.visitSingularStringField(value: self.blockHash, fieldNumber: 12)
        }
        if self.blockTime != 0 {
            try visitor.visitSingularUInt64Field(value: self.blockTime, fieldNumber: 14)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_RpcTransactionVerboseData, rhs: Protowire_RpcTransactionVerboseData) -> Bool {
        if lhs.transactionID != rhs.transactionID {return false}
        if lhs.hash != rhs.hash {return false}
        if lhs.mass != rhs.mass {return false}
        if lhs.blockHash != rhs.blockHash {return false}
        if lhs.blockTime != rhs.blockTime {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcTransactionInputVerboseData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcTransactionInputVerboseData"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_RpcTransactionInputVerboseData, rhs: Protowire_RpcTransactionInputVerboseData) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcTransactionOutputVerboseData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcTransactionOutputVerboseData"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        5: .same(proto: "scriptPublicKeyType"),
        6: .same(proto: "scriptPublicKeyAddress"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 5: try { try decoder.decodeSingularStringField(value: &self.scriptPublicKeyType) }()
            case 6: try { try decoder.decodeSingularStringField(value: &self.scriptPublicKeyAddress) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.scriptPublicKeyType.isEmpty {
            try visitor.visitSingularStringField(value: self.scriptPublicKeyType, fieldNumber: 5)
        }
        if !self.scriptPublicKeyAddress.isEmpty {
            try visitor.visitSingularStringField(value: self.scriptPublicKeyAddress, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_RpcTransactionOutputVerboseData, rhs: Protowire_RpcTransactionOutputVerboseData) -> Bool {
        if lhs.scriptPublicKeyType != rhs.scriptPublicKeyType {return false}
        if lhs.scriptPublicKeyAddress != rhs.scriptPublicKeyAddress {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetCurrentNetworkRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetCurrentNetworkRequestMessage"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetCurrentNetworkRequestMessage, rhs: Protowire_GetCurrentNetworkRequestMessage) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetCurrentNetworkResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetCurrentNetworkResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "currentNetwork"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.currentNetwork) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.currentNetwork.isEmpty {
            try visitor.visitSingularStringField(value: self.currentNetwork, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetCurrentNetworkResponseMessage, rhs: Protowire_GetCurrentNetworkResponseMessage) -> Bool {
        if lhs.currentNetwork != rhs.currentNetwork {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_SubmitBlockRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SubmitBlockRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        2: .same(proto: "block"),
        3: .same(proto: "allowNonDAABlocks"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 2: try { try decoder.decodeSingularMessageField(value: &self._block) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self.allowNonDaablocks) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._block {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        if self.allowNonDaablocks != false {
            try visitor.visitSingularBoolField(value: self.allowNonDaablocks, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_SubmitBlockRequestMessage, rhs: Protowire_SubmitBlockRequestMessage) -> Bool {
        if lhs._block != rhs._block {return false}
        if lhs.allowNonDaablocks != rhs.allowNonDaablocks {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_SubmitBlockResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SubmitBlockResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "rejectReason"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularEnumField(value: &self.rejectReason) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.rejectReason != .none {
            try visitor.visitSingularEnumField(value: self.rejectReason, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_SubmitBlockResponseMessage, rhs: Protowire_SubmitBlockResponseMessage) -> Bool {
        if lhs.rejectReason != rhs.rejectReason {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_SubmitBlockResponseMessage.RejectReason: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "NONE"),
        1: .same(proto: "BLOCK_INVALID"),
        2: .same(proto: "IS_IN_IBD"),
    ]
}

extension Protowire_GetBlockTemplateRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetBlockTemplateRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "payAddress"),
        2: .same(proto: "extraData"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.payAddress) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.extraData) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.payAddress.isEmpty {
            try visitor.visitSingularStringField(value: self.payAddress, fieldNumber: 1)
        }
        if !self.extraData.isEmpty {
            try visitor.visitSingularStringField(value: self.extraData, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetBlockTemplateRequestMessage, rhs: Protowire_GetBlockTemplateRequestMessage) -> Bool {
        if lhs.payAddress != rhs.payAddress {return false}
        if lhs.extraData != rhs.extraData {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetBlockTemplateResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetBlockTemplateResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        3: .same(proto: "block"),
        2: .same(proto: "isSynced"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 2: try { try decoder.decodeSingularBoolField(value: &self.isSynced) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._block) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.isSynced != false {
            try visitor.visitSingularBoolField(value: self.isSynced, fieldNumber: 2)
        }
        try { if let v = self._block {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetBlockTemplateResponseMessage, rhs: Protowire_GetBlockTemplateResponseMessage) -> Bool {
        if lhs._block != rhs._block {return false}
        if lhs.isSynced != rhs.isSynced {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_NotifyBlockAddedRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NotifyBlockAddedRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        101: .same(proto: "command"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 101: try { try decoder.decodeSingularEnumField(value: &self.command) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.command != .notifyStart {
            try visitor.visitSingularEnumField(value: self.command, fieldNumber: 101)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_NotifyBlockAddedRequestMessage, rhs: Protowire_NotifyBlockAddedRequestMessage) -> Bool {
        if lhs.command != rhs.command {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_NotifyBlockAddedResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NotifyBlockAddedResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_NotifyBlockAddedResponseMessage, rhs: Protowire_NotifyBlockAddedResponseMessage) -> Bool {
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_BlockAddedNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".BlockAddedNotificationMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        3: .same(proto: "block"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 3: try { try decoder.decodeSingularMessageField(value: &self._block) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._block {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_BlockAddedNotificationMessage, rhs: Protowire_BlockAddedNotificationMessage) -> Bool {
        if lhs._block != rhs._block {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetPeerAddressesRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetPeerAddressesRequestMessage"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetPeerAddressesRequestMessage, rhs: Protowire_GetPeerAddressesRequestMessage) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetPeerAddressesResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetPeerAddressesResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "addresses"),
        2: .same(proto: "bannedAddresses"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.addresses) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.bannedAddresses) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.addresses.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.addresses, fieldNumber: 1)
        }
        if !self.bannedAddresses.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.bannedAddresses, fieldNumber: 2)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetPeerAddressesResponseMessage, rhs: Protowire_GetPeerAddressesResponseMessage) -> Bool {
        if lhs.addresses != rhs.addresses {return false}
        if lhs.bannedAddresses != rhs.bannedAddresses {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetPeerAddressesKnownAddressMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetPeerAddressesKnownAddressMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "Addr"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.addr) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.addr.isEmpty {
            try visitor.visitSingularStringField(value: self.addr, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetPeerAddressesKnownAddressMessage, rhs: Protowire_GetPeerAddressesKnownAddressMessage) -> Bool {
        if lhs.addr != rhs.addr {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetSinkRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetSinkRequestMessage"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetSinkRequestMessage, rhs: Protowire_GetSinkRequestMessage) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetSinkResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetSinkResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "sink"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.sink) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.sink.isEmpty {
            try visitor.visitSingularStringField(value: self.sink, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetSinkResponseMessage, rhs: Protowire_GetSinkResponseMessage) -> Bool {
        if lhs.sink != rhs.sink {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetMempoolEntryRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetMempoolEntryRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "txId"),
        2: .same(proto: "includeOrphanPool"),
        3: .same(proto: "filterTransactionPool"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.txID) }()
            case 2: try { try decoder.decodeSingularBoolField(value: &self.includeOrphanPool) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self.filterTransactionPool) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.txID.isEmpty {
            try visitor.visitSingularStringField(value: self.txID, fieldNumber: 1)
        }
        if self.includeOrphanPool != false {
            try visitor.visitSingularBoolField(value: self.includeOrphanPool, fieldNumber: 2)
        }
        if self.filterTransactionPool != false {
            try visitor.visitSingularBoolField(value: self.filterTransactionPool, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetMempoolEntryRequestMessage, rhs: Protowire_GetMempoolEntryRequestMessage) -> Bool {
        if lhs.txID != rhs.txID {return false}
        if lhs.includeOrphanPool != rhs.includeOrphanPool {return false}
        if lhs.filterTransactionPool != rhs.filterTransactionPool {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetMempoolEntryResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetMempoolEntryResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "entry"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._entry) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._entry {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetMempoolEntryResponseMessage, rhs: Protowire_GetMempoolEntryResponseMessage) -> Bool {
        if lhs._entry != rhs._entry {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetMempoolEntriesRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetMempoolEntriesRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "includeOrphanPool"),
        2: .same(proto: "filterTransactionPool"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBoolField(value: &self.includeOrphanPool) }()
            case 2: try { try decoder.decodeSingularBoolField(value: &self.filterTransactionPool) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.includeOrphanPool != false {
            try visitor.visitSingularBoolField(value: self.includeOrphanPool, fieldNumber: 1)
        }
        if self.filterTransactionPool != false {
            try visitor.visitSingularBoolField(value: self.filterTransactionPool, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetMempoolEntriesRequestMessage, rhs: Protowire_GetMempoolEntriesRequestMessage) -> Bool {
        if lhs.includeOrphanPool != rhs.includeOrphanPool {return false}
        if lhs.filterTransactionPool != rhs.filterTransactionPool {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetMempoolEntriesResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetMempoolEntriesResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "entries"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.entries.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetMempoolEntriesResponseMessage, rhs: Protowire_GetMempoolEntriesResponseMessage) -> Bool {
        if lhs.entries != rhs.entries {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcMempoolEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcMempoolEntry"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "fee"),
        3: .same(proto: "transaction"),
        4: .same(proto: "isOrphan"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt64Field(value: &self.fee) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
            case 4: try { try decoder.decodeSingularBoolField(value: &self.isOrphan) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.fee != 0 {
            try visitor.visitSingularUInt64Field(value: self.fee, fieldNumber: 1)
        }
        try { if let v = self._transaction {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        if self.isOrphan != false {
            try visitor.visitSingularBoolField(value: self.isOrphan, fieldNumber: 4)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_RpcMempoolEntry, rhs: Protowire_RpcMempoolEntry) -> Bool {
        if lhs.fee != rhs.fee {return false}
        if lhs._transaction != rhs._transaction {return false}
        if lhs.isOrphan != rhs.isOrphan {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetConnectedPeerInfoRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetConnectedPeerInfoRequestMessage"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetConnectedPeerInfoRequestMessage, rhs: Protowire_GetConnectedPeerInfoRequestMessage) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetConnectedPeerInfoResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetConnectedPeerInfoResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "infos"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.infos) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.infos.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.infos, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetConnectedPeerInfoResponseMessage, rhs: Protowire_GetConnectedPeerInfoResponseMessage) -> Bool {
        if lhs.infos != rhs.infos {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetConnectedPeerInfoMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetConnectedPeerInfoMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "address"),
        3: .same(proto: "lastPingDuration"),
        6: .same(proto: "isOutbound"),
        7: .same(proto: "timeOffset"),
        8: .same(proto: "userAgent"),
        9: .same(proto: "advertisedProtocolVersion"),
        10: .same(proto: "timeConnected"),
        11: .same(proto: "isIbdPeer"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
            case 3: try { try decoder.decodeSingularInt64Field(value: &self.lastPingDuration) }()
            case 6: try { try decoder.decodeSingularBoolField(value: &self.isOutbound) }()
            case 7: try { try decoder.decodeSingularInt64Field(value: &self.timeOffset) }()
            case 8: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
            case 9: try { try decoder.decodeSingularUInt32Field(value: &self.advertisedProtocolVersion) }()
            case 10: try { try decoder.decodeSingularInt64Field(value: &self.timeConnected) }()
            case 11: try { try decoder.decodeSingularBoolField(value: &self.isIbdPeer) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.id.isEmpty {
            try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
        }
        if !self.address.isEmpty {
            try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
        }
        if self.lastPingDuration != 0 {
            try visitor.visitSingularInt64Field(value: self.lastPingDuration, fieldNumber: 3)
        }
        if self.isOutbound != false {
            try visitor.visitSingularBoolField(value: self.isOutbound, fieldNumber: 6)
        }
        if self.timeOffset != 0 {
            try visitor.visitSingularInt64Field(value: self.timeOffset, fieldNumber: 7)
        }
        if !self.userAgent.isEmpty {
            try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 8)
        }
        if self.advertisedProtocolVersion != 0 {
            try visitor.visitSingularUInt32Field(value: self.advertisedProtocolVersion, fieldNumber: 9)
        }
        if self.timeConnected != 0 {
            try visitor.visitSingularInt64Field(value: self.timeConnected, fieldNumber: 10)
        }
        if self.isIbdPeer != false {
            try visitor.visitSingularBoolField(value: self.isIbdPeer, fieldNumber: 11)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetConnectedPeerInfoMessage, rhs: Protowire_GetConnectedPeerInfoMessage) -> Bool {
        if lhs.id != rhs.id {return false}
        if lhs.address != rhs.address {return false}
        if lhs.lastPingDuration != rhs.lastPingDuration {return false}
        if lhs.isOutbound != rhs.isOutbound {return false}
        if lhs.timeOffset != rhs.timeOffset {return false}
        if lhs.userAgent != rhs.userAgent {return false}
        if lhs.advertisedProtocolVersion != rhs.advertisedProtocolVersion {return false}
        if lhs.timeConnected != rhs.timeConnected {return false}
        if lhs.isIbdPeer != rhs.isIbdPeer {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_AddPeerRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".AddPeerRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "address"),
        2: .same(proto: "isPermanent"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
            case 2: try { try decoder.decodeSingularBoolField(value: &self.isPermanent) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.address.isEmpty {
            try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
        }
        if self.isPermanent != false {
            try visitor.visitSingularBoolField(value: self.isPermanent, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_AddPeerRequestMessage, rhs: Protowire_AddPeerRequestMessage) -> Bool {
        if lhs.address != rhs.address {return false}
        if lhs.isPermanent != rhs.isPermanent {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_AddPeerResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".AddPeerResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_AddPeerResponseMessage, rhs: Protowire_AddPeerResponseMessage) -> Bool {
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_SubmitTransactionRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SubmitTransactionRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "transaction"),
        2: .same(proto: "allowOrphan"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
            case 2: try { try decoder.decodeSingularBoolField(value: &self.allowOrphan) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._transaction {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if self.allowOrphan != false {
            try visitor.visitSingularBoolField(value: self.allowOrphan, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_SubmitTransactionRequestMessage, rhs: Protowire_SubmitTransactionRequestMessage) -> Bool {
        if lhs._transaction != rhs._transaction {return false}
        if lhs.allowOrphan != rhs.allowOrphan {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_SubmitTransactionResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SubmitTransactionResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "transactionId"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.transactionID.isEmpty {
            try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_SubmitTransactionResponseMessage, rhs: Protowire_SubmitTransactionResponseMessage) -> Bool {
        if lhs.transactionID != rhs.transactionID {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_SubmitTransactionReplacementRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SubmitTransactionReplacementRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "transaction"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._transaction {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_SubmitTransactionReplacementRequestMessage, rhs: Protowire_SubmitTransactionReplacementRequestMessage) -> Bool {
        if lhs._transaction != rhs._transaction {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_SubmitTransactionReplacementResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SubmitTransactionReplacementResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "transactionId"),
        2: .same(proto: "replacedTransaction"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._replacedTransaction) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.transactionID.isEmpty {
            try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
        }
        try { if let v = self._replacedTransaction {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_SubmitTransactionReplacementResponseMessage, rhs: Protowire_SubmitTransactionReplacementResponseMessage) -> Bool {
        if lhs.transactionID != rhs.transactionID {return false}
        if lhs._replacedTransaction != rhs._replacedTransaction {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_NotifyVirtualChainChangedRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NotifyVirtualChainChangedRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "includeAcceptedTransactionIds"),
        101: .same(proto: "command"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBoolField(value: &self.includeAcceptedTransactionIds) }()
            case 101: try { try decoder.decodeSingularEnumField(value: &self.command) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.includeAcceptedTransactionIds != false {
            try visitor.visitSingularBoolField(value: self.includeAcceptedTransactionIds, fieldNumber: 1)
        }
        if self.command != .notifyStart {
            try visitor.visitSingularEnumField(value: self.command, fieldNumber: 101)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_NotifyVirtualChainChangedRequestMessage, rhs: Protowire_NotifyVirtualChainChangedRequestMessage) -> Bool {
        if lhs.includeAcceptedTransactionIds != rhs.includeAcceptedTransactionIds {return false}
        if lhs.command != rhs.command {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_NotifyVirtualChainChangedResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NotifyVirtualChainChangedResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_NotifyVirtualChainChangedResponseMessage, rhs: Protowire_NotifyVirtualChainChangedResponseMessage) -> Bool {
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_VirtualChainChangedNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".VirtualChainChangedNotificationMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "removedChainBlockHashes"),
        3: .same(proto: "addedChainBlockHashes"),
        2: .same(proto: "acceptedTransactionIds"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedStringField(value: &self.removedChainBlockHashes) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.acceptedTransactionIds) }()
            case 3: try { try decoder.decodeRepeatedStringField(value: &self.addedChainBlockHashes) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.removedChainBlockHashes.isEmpty {
            try visitor.visitRepeatedStringField(value: self.removedChainBlockHashes, fieldNumber: 1)
        }
        if !self.acceptedTransactionIds.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.acceptedTransactionIds, fieldNumber: 2)
        }
        if !self.addedChainBlockHashes.isEmpty {
            try visitor.visitRepeatedStringField(value: self.addedChainBlockHashes, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_VirtualChainChangedNotificationMessage, rhs: Protowire_VirtualChainChangedNotificationMessage) -> Bool {
        if lhs.removedChainBlockHashes != rhs.removedChainBlockHashes {return false}
        if lhs.addedChainBlockHashes != rhs.addedChainBlockHashes {return false}
        if lhs.acceptedTransactionIds != rhs.acceptedTransactionIds {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetBlockRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetBlockRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "hash"),
        3: .same(proto: "includeTransactions"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self.includeTransactions) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.hash.isEmpty {
            try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
        }
        if self.includeTransactions != false {
            try visitor.visitSingularBoolField(value: self.includeTransactions, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetBlockRequestMessage, rhs: Protowire_GetBlockRequestMessage) -> Bool {
        if lhs.hash != rhs.hash {return false}
        if lhs.includeTransactions != rhs.includeTransactions {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetBlockResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetBlockResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        3: .same(proto: "block"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 3: try { try decoder.decodeSingularMessageField(value: &self._block) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._block {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetBlockResponseMessage, rhs: Protowire_GetBlockResponseMessage) -> Bool {
        if lhs._block != rhs._block {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetSubnetworkRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetSubnetworkRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "subnetworkId"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.subnetworkID) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.subnetworkID.isEmpty {
            try visitor.visitSingularStringField(value: self.subnetworkID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetSubnetworkRequestMessage, rhs: Protowire_GetSubnetworkRequestMessage) -> Bool {
        if lhs.subnetworkID != rhs.subnetworkID {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetSubnetworkResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetSubnetworkResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "gasLimit"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt64Field(value: &self.gasLimit) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.gasLimit != 0 {
            try visitor.visitSingularUInt64Field(value: self.gasLimit, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetSubnetworkResponseMessage, rhs: Protowire_GetSubnetworkResponseMessage) -> Bool {
        if lhs.gasLimit != rhs.gasLimit {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetVirtualChainFromBlockRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetVirtualChainFromBlockRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "startHash"),
        2: .same(proto: "includeAcceptedTransactionIds"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.startHash) }()
            case 2: try { try decoder.decodeSingularBoolField(value: &self.includeAcceptedTransactionIds) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.startHash.isEmpty {
            try visitor.visitSingularStringField(value: self.startHash, fieldNumber: 1)
        }
        if self.includeAcceptedTransactionIds != false {
            try visitor.visitSingularBoolField(value: self.includeAcceptedTransactionIds, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetVirtualChainFromBlockRequestMessage, rhs: Protowire_GetVirtualChainFromBlockRequestMessage) -> Bool {
        if lhs.startHash != rhs.startHash {return false}
        if lhs.includeAcceptedTransactionIds != rhs.includeAcceptedTransactionIds {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcAcceptedTransactionIds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcAcceptedTransactionIds"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "acceptingBlockHash"),
        2: .same(proto: "acceptedTransactionIds"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.acceptingBlockHash) }()
            case 2: try { try decoder.decodeRepeatedStringField(value: &self.acceptedTransactionIds) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.acceptingBlockHash.isEmpty {
            try visitor.visitSingularStringField(value: self.acceptingBlockHash, fieldNumber: 1)
        }
        if !self.acceptedTransactionIds.isEmpty {
            try visitor.visitRepeatedStringField(value: self.acceptedTransactionIds, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_RpcAcceptedTransactionIds, rhs: Protowire_RpcAcceptedTransactionIds) -> Bool {
        if lhs.acceptingBlockHash != rhs.acceptingBlockHash {return false}
        if lhs.acceptedTransactionIds != rhs.acceptedTransactionIds {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetVirtualChainFromBlockResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetVirtualChainFromBlockResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "removedChainBlockHashes"),
        3: .same(proto: "addedChainBlockHashes"),
        2: .same(proto: "acceptedTransactionIds"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedStringField(value: &self.removedChainBlockHashes) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.acceptedTransactionIds) }()
            case 3: try { try decoder.decodeRepeatedStringField(value: &self.addedChainBlockHashes) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.removedChainBlockHashes.isEmpty {
            try visitor.visitRepeatedStringField(value: self.removedChainBlockHashes, fieldNumber: 1)
        }
        if !self.acceptedTransactionIds.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.acceptedTransactionIds, fieldNumber: 2)
        }
        if !self.addedChainBlockHashes.isEmpty {
            try visitor.visitRepeatedStringField(value: self.addedChainBlockHashes, fieldNumber: 3)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetVirtualChainFromBlockResponseMessage, rhs: Protowire_GetVirtualChainFromBlockResponseMessage) -> Bool {
        if lhs.removedChainBlockHashes != rhs.removedChainBlockHashes {return false}
        if lhs.addedChainBlockHashes != rhs.addedChainBlockHashes {return false}
        if lhs.acceptedTransactionIds != rhs.acceptedTransactionIds {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetBlocksRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetBlocksRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "lowHash"),
        2: .same(proto: "includeBlocks"),
        3: .same(proto: "includeTransactions"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.lowHash) }()
            case 2: try { try decoder.decodeSingularBoolField(value: &self.includeBlocks) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self.includeTransactions) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.lowHash.isEmpty {
            try visitor.visitSingularStringField(value: self.lowHash, fieldNumber: 1)
        }
        if self.includeBlocks != false {
            try visitor.visitSingularBoolField(value: self.includeBlocks, fieldNumber: 2)
        }
        if self.includeTransactions != false {
            try visitor.visitSingularBoolField(value: self.includeTransactions, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetBlocksRequestMessage, rhs: Protowire_GetBlocksRequestMessage) -> Bool {
        if lhs.lowHash != rhs.lowHash {return false}
        if lhs.includeBlocks != rhs.includeBlocks {return false}
        if lhs.includeTransactions != rhs.includeTransactions {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetBlocksResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetBlocksResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        4: .same(proto: "blockHashes"),
        3: .same(proto: "blocks"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 3: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
            case 4: try { try decoder.decodeRepeatedStringField(value: &self.blockHashes) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.blocks.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 3)
        }
        if !self.blockHashes.isEmpty {
            try visitor.visitRepeatedStringField(value: self.blockHashes, fieldNumber: 4)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetBlocksResponseMessage, rhs: Protowire_GetBlocksResponseMessage) -> Bool {
        if lhs.blockHashes != rhs.blockHashes {return false}
        if lhs.blocks != rhs.blocks {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetBlockCountRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetBlockCountRequestMessage"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetBlockCountRequestMessage, rhs: Protowire_GetBlockCountRequestMessage) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetBlockCountResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetBlockCountResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "blockCount"),
        2: .same(proto: "headerCount"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt64Field(value: &self.blockCount) }()
            case 2: try { try decoder.decodeSingularUInt64Field(value: &self.headerCount) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.blockCount != 0 {
            try visitor.visitSingularUInt64Field(value: self.blockCount, fieldNumber: 1)
        }
        if self.headerCount != 0 {
            try visitor.visitSingularUInt64Field(value: self.headerCount, fieldNumber: 2)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetBlockCountResponseMessage, rhs: Protowire_GetBlockCountResponseMessage) -> Bool {
        if lhs.blockCount != rhs.blockCount {return false}
        if lhs.headerCount != rhs.headerCount {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetBlockDagInfoRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetBlockDagInfoRequestMessage"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetBlockDagInfoRequestMessage, rhs: Protowire_GetBlockDagInfoRequestMessage) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetBlockDagInfoResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetBlockDagInfoResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "networkName"),
        2: .same(proto: "blockCount"),
        3: .same(proto: "headerCount"),
        4: .same(proto: "tipHashes"),
        5: .same(proto: "difficulty"),
        6: .same(proto: "pastMedianTime"),
        7: .same(proto: "virtualParentHashes"),
        8: .same(proto: "pruningPointHash"),
        9: .same(proto: "virtualDaaScore"),
        10: .same(proto: "sink"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.networkName) }()
            case 2: try { try decoder.decodeSingularUInt64Field(value: &self.blockCount) }()
            case 3: try { try decoder.decodeSingularUInt64Field(value: &self.headerCount) }()
            case 4: try { try decoder.decodeRepeatedStringField(value: &self.tipHashes) }()
            case 5: try { try decoder.decodeSingularDoubleField(value: &self.difficulty) }()
            case 6: try { try decoder.decodeSingularInt64Field(value: &self.pastMedianTime) }()
            case 7: try { try decoder.decodeRepeatedStringField(value: &self.virtualParentHashes) }()
            case 8: try { try decoder.decodeSingularStringField(value: &self.pruningPointHash) }()
            case 9: try { try decoder.decodeSingularUInt64Field(value: &self.virtualDaaScore) }()
            case 10: try { try decoder.decodeSingularStringField(value: &self.sink) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.networkName.isEmpty {
            try visitor.visitSingularStringField(value: self.networkName, fieldNumber: 1)
        }
        if self.blockCount != 0 {
            try visitor.visitSingularUInt64Field(value: self.blockCount, fieldNumber: 2)
        }
        if self.headerCount != 0 {
            try visitor.visitSingularUInt64Field(value: self.headerCount, fieldNumber: 3)
        }
        if !self.tipHashes.isEmpty {
            try visitor.visitRepeatedStringField(value: self.tipHashes, fieldNumber: 4)
        }
        if self.difficulty.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: self.difficulty, fieldNumber: 5)
        }
        if self.pastMedianTime != 0 {
            try visitor.visitSingularInt64Field(value: self.pastMedianTime, fieldNumber: 6)
        }
        if !self.virtualParentHashes.isEmpty {
            try visitor.visitRepeatedStringField(value: self.virtualParentHashes, fieldNumber: 7)
        }
        if !self.pruningPointHash.isEmpty {
            try visitor.visitSingularStringField(value: self.pruningPointHash, fieldNumber: 8)
        }
        if self.virtualDaaScore != 0 {
            try visitor.visitSingularUInt64Field(value: self.virtualDaaScore, fieldNumber: 9)
        }
        if !self.sink.isEmpty {
            try visitor.visitSingularStringField(value: self.sink, fieldNumber: 10)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetBlockDagInfoResponseMessage, rhs: Protowire_GetBlockDagInfoResponseMessage) -> Bool {
        if lhs.networkName != rhs.networkName {return false}
        if lhs.blockCount != rhs.blockCount {return false}
        if lhs.headerCount != rhs.headerCount {return false}
        if lhs.tipHashes != rhs.tipHashes {return false}
        if lhs.difficulty != rhs.difficulty {return false}
        if lhs.pastMedianTime != rhs.pastMedianTime {return false}
        if lhs.virtualParentHashes != rhs.virtualParentHashes {return false}
        if lhs.pruningPointHash != rhs.pruningPointHash {return false}
        if lhs.virtualDaaScore != rhs.virtualDaaScore {return false}
        if lhs.sink != rhs.sink {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_ResolveFinalityConflictRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ResolveFinalityConflictRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "finalityBlockHash"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.finalityBlockHash) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.finalityBlockHash.isEmpty {
            try visitor.visitSingularStringField(value: self.finalityBlockHash, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_ResolveFinalityConflictRequestMessage, rhs: Protowire_ResolveFinalityConflictRequestMessage) -> Bool {
        if lhs.finalityBlockHash != rhs.finalityBlockHash {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_ResolveFinalityConflictResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ResolveFinalityConflictResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_ResolveFinalityConflictResponseMessage, rhs: Protowire_ResolveFinalityConflictResponseMessage) -> Bool {
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_NotifyFinalityConflictRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NotifyFinalityConflictRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        101: .same(proto: "command"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 101: try { try decoder.decodeSingularEnumField(value: &self.command) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.command != .notifyStart {
            try visitor.visitSingularEnumField(value: self.command, fieldNumber: 101)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_NotifyFinalityConflictRequestMessage, rhs: Protowire_NotifyFinalityConflictRequestMessage) -> Bool {
        if lhs.command != rhs.command {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_NotifyFinalityConflictResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NotifyFinalityConflictResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_NotifyFinalityConflictResponseMessage, rhs: Protowire_NotifyFinalityConflictResponseMessage) -> Bool {
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_FinalityConflictNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".FinalityConflictNotificationMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "violatingBlockHash"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.violatingBlockHash) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.violatingBlockHash.isEmpty {
            try visitor.visitSingularStringField(value: self.violatingBlockHash, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_FinalityConflictNotificationMessage, rhs: Protowire_FinalityConflictNotificationMessage) -> Bool {
        if lhs.violatingBlockHash != rhs.violatingBlockHash {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_FinalityConflictResolvedNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".FinalityConflictResolvedNotificationMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "finalityBlockHash"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.finalityBlockHash) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.finalityBlockHash.isEmpty {
            try visitor.visitSingularStringField(value: self.finalityBlockHash, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_FinalityConflictResolvedNotificationMessage, rhs: Protowire_FinalityConflictResolvedNotificationMessage) -> Bool {
        if lhs.finalityBlockHash != rhs.finalityBlockHash {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_ShutdownRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ShutdownRequestMessage"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_ShutdownRequestMessage, rhs: Protowire_ShutdownRequestMessage) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_ShutdownResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ShutdownResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_ShutdownResponseMessage, rhs: Protowire_ShutdownResponseMessage) -> Bool {
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetHeadersRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetHeadersRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "startHash"),
        2: .same(proto: "limit"),
        3: .same(proto: "isAscending"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.startHash) }()
            case 2: try { try decoder.decodeSingularUInt64Field(value: &self.limit) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self.isAscending) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.startHash.isEmpty {
            try visitor.visitSingularStringField(value: self.startHash, fieldNumber: 1)
        }
        if self.limit != 0 {
            try visitor.visitSingularUInt64Field(value: self.limit, fieldNumber: 2)
        }
        if self.isAscending != false {
            try visitor.visitSingularBoolField(value: self.isAscending, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetHeadersRequestMessage, rhs: Protowire_GetHeadersRequestMessage) -> Bool {
        if lhs.startHash != rhs.startHash {return false}
        if lhs.limit != rhs.limit {return false}
        if lhs.isAscending != rhs.isAscending {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetHeadersResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetHeadersResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "headers"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedStringField(value: &self.headers) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.headers.isEmpty {
            try visitor.visitRepeatedStringField(value: self.headers, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetHeadersResponseMessage, rhs: Protowire_GetHeadersResponseMessage) -> Bool {
        if lhs.headers != rhs.headers {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_NotifyUtxosChangedRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NotifyUtxosChangedRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "addresses"),
        101: .same(proto: "command"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
            case 101: try { try decoder.decodeSingularEnumField(value: &self.command) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.addresses.isEmpty {
            try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 1)
        }
        if self.command != .notifyStart {
            try visitor.visitSingularEnumField(value: self.command, fieldNumber: 101)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_NotifyUtxosChangedRequestMessage, rhs: Protowire_NotifyUtxosChangedRequestMessage) -> Bool {
        if lhs.addresses != rhs.addresses {return false}
        if lhs.command != rhs.command {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_NotifyUtxosChangedResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NotifyUtxosChangedResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_NotifyUtxosChangedResponseMessage, rhs: Protowire_NotifyUtxosChangedResponseMessage) -> Bool {
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_UtxosChangedNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UtxosChangedNotificationMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "added"),
        2: .same(proto: "removed"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.added) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.removed) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.added.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.added, fieldNumber: 1)
        }
        if !self.removed.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.removed, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_UtxosChangedNotificationMessage, rhs: Protowire_UtxosChangedNotificationMessage) -> Bool {
        if lhs.added != rhs.added {return false}
        if lhs.removed != rhs.removed {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcUtxosByAddressesEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcUtxosByAddressesEntry"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "address"),
        2: .same(proto: "outpoint"),
        3: .same(proto: "utxoEntry"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._utxoEntry) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.address.isEmpty {
            try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
        }
        try { if let v = self._outpoint {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._utxoEntry {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_RpcUtxosByAddressesEntry, rhs: Protowire_RpcUtxosByAddressesEntry) -> Bool {
        if lhs.address != rhs.address {return false}
        if lhs._outpoint != rhs._outpoint {return false}
        if lhs._utxoEntry != rhs._utxoEntry {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_StopNotifyingUtxosChangedRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".StopNotifyingUtxosChangedRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "addresses"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.addresses.isEmpty {
            try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_StopNotifyingUtxosChangedRequestMessage, rhs: Protowire_StopNotifyingUtxosChangedRequestMessage) -> Bool {
        if lhs.addresses != rhs.addresses {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_StopNotifyingUtxosChangedResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".StopNotifyingUtxosChangedResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_StopNotifyingUtxosChangedResponseMessage, rhs: Protowire_StopNotifyingUtxosChangedResponseMessage) -> Bool {
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetUtxosByAddressesRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetUtxosByAddressesRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "addresses"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.addresses.isEmpty {
            try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetUtxosByAddressesRequestMessage, rhs: Protowire_GetUtxosByAddressesRequestMessage) -> Bool {
        if lhs.addresses != rhs.addresses {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetUtxosByAddressesResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetUtxosByAddressesResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "entries"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.entries.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetUtxosByAddressesResponseMessage, rhs: Protowire_GetUtxosByAddressesResponseMessage) -> Bool {
        if lhs.entries != rhs.entries {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetBalanceByAddressRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetBalanceByAddressRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "address"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.address.isEmpty {
            try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetBalanceByAddressRequestMessage, rhs: Protowire_GetBalanceByAddressRequestMessage) -> Bool {
        if lhs.address != rhs.address {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetBalanceByAddressResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetBalanceByAddressResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "balance"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt64Field(value: &self.balance) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.balance != 0 {
            try visitor.visitSingularUInt64Field(value: self.balance, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetBalanceByAddressResponseMessage, rhs: Protowire_GetBalanceByAddressResponseMessage) -> Bool {
        if lhs.balance != rhs.balance {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetBalancesByAddressesRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetBalancesByAddressesRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "addresses"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.addresses.isEmpty {
            try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetBalancesByAddressesRequestMessage, rhs: Protowire_GetBalancesByAddressesRequestMessage) -> Bool {
        if lhs.addresses != rhs.addresses {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcBalancesByAddressesEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcBalancesByAddressesEntry"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "address"),
        2: .same(proto: "balance"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
            case 2: try { try decoder.decodeSingularUInt64Field(value: &self.balance) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.address.isEmpty {
            try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
        }
        if self.balance != 0 {
            try visitor.visitSingularUInt64Field(value: self.balance, fieldNumber: 2)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_RpcBalancesByAddressesEntry, rhs: Protowire_RpcBalancesByAddressesEntry) -> Bool {
        if lhs.address != rhs.address {return false}
        if lhs.balance != rhs.balance {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetBalancesByAddressesResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetBalancesByAddressesResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "entries"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.entries.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetBalancesByAddressesResponseMessage, rhs: Protowire_GetBalancesByAddressesResponseMessage) -> Bool {
        if lhs.entries != rhs.entries {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetSinkBlueScoreRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetSinkBlueScoreRequestMessage"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetSinkBlueScoreRequestMessage, rhs: Protowire_GetSinkBlueScoreRequestMessage) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetSinkBlueScoreResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetSinkBlueScoreResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "blueScore"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt64Field(value: &self.blueScore) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.blueScore != 0 {
            try visitor.visitSingularUInt64Field(value: self.blueScore, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetSinkBlueScoreResponseMessage, rhs: Protowire_GetSinkBlueScoreResponseMessage) -> Bool {
        if lhs.blueScore != rhs.blueScore {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_NotifySinkBlueScoreChangedRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NotifySinkBlueScoreChangedRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        101: .same(proto: "command"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 101: try { try decoder.decodeSingularEnumField(value: &self.command) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.command != .notifyStart {
            try visitor.visitSingularEnumField(value: self.command, fieldNumber: 101)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_NotifySinkBlueScoreChangedRequestMessage, rhs: Protowire_NotifySinkBlueScoreChangedRequestMessage) -> Bool {
        if lhs.command != rhs.command {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_NotifySinkBlueScoreChangedResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NotifySinkBlueScoreChangedResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_NotifySinkBlueScoreChangedResponseMessage, rhs: Protowire_NotifySinkBlueScoreChangedResponseMessage) -> Bool {
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_SinkBlueScoreChangedNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".SinkBlueScoreChangedNotificationMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "sinkBlueScore"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt64Field(value: &self.sinkBlueScore) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.sinkBlueScore != 0 {
            try visitor.visitSingularUInt64Field(value: self.sinkBlueScore, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_SinkBlueScoreChangedNotificationMessage, rhs: Protowire_SinkBlueScoreChangedNotificationMessage) -> Bool {
        if lhs.sinkBlueScore != rhs.sinkBlueScore {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_NotifyVirtualDaaScoreChangedRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NotifyVirtualDaaScoreChangedRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        101: .same(proto: "command"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 101: try { try decoder.decodeSingularEnumField(value: &self.command) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.command != .notifyStart {
            try visitor.visitSingularEnumField(value: self.command, fieldNumber: 101)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_NotifyVirtualDaaScoreChangedRequestMessage, rhs: Protowire_NotifyVirtualDaaScoreChangedRequestMessage) -> Bool {
        if lhs.command != rhs.command {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_NotifyVirtualDaaScoreChangedResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NotifyVirtualDaaScoreChangedResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_NotifyVirtualDaaScoreChangedResponseMessage, rhs: Protowire_NotifyVirtualDaaScoreChangedResponseMessage) -> Bool {
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_VirtualDaaScoreChangedNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".VirtualDaaScoreChangedNotificationMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "virtualDaaScore"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt64Field(value: &self.virtualDaaScore) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.virtualDaaScore != 0 {
            try visitor.visitSingularUInt64Field(value: self.virtualDaaScore, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_VirtualDaaScoreChangedNotificationMessage, rhs: Protowire_VirtualDaaScoreChangedNotificationMessage) -> Bool {
        if lhs.virtualDaaScore != rhs.virtualDaaScore {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_NotifyPruningPointUtxoSetOverrideRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NotifyPruningPointUtxoSetOverrideRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        101: .same(proto: "command"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 101: try { try decoder.decodeSingularEnumField(value: &self.command) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.command != .notifyStart {
            try visitor.visitSingularEnumField(value: self.command, fieldNumber: 101)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_NotifyPruningPointUtxoSetOverrideRequestMessage, rhs: Protowire_NotifyPruningPointUtxoSetOverrideRequestMessage) -> Bool {
        if lhs.command != rhs.command {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_NotifyPruningPointUtxoSetOverrideResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NotifyPruningPointUtxoSetOverrideResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_NotifyPruningPointUtxoSetOverrideResponseMessage, rhs: Protowire_NotifyPruningPointUtxoSetOverrideResponseMessage) -> Bool {
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_PruningPointUtxoSetOverrideNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".PruningPointUtxoSetOverrideNotificationMessage"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_PruningPointUtxoSetOverrideNotificationMessage, rhs: Protowire_PruningPointUtxoSetOverrideNotificationMessage) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_StopNotifyingPruningPointUtxoSetOverrideRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".StopNotifyingPruningPointUtxoSetOverrideRequestMessage"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_StopNotifyingPruningPointUtxoSetOverrideRequestMessage, rhs: Protowire_StopNotifyingPruningPointUtxoSetOverrideRequestMessage) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_StopNotifyingPruningPointUtxoSetOverrideResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".StopNotifyingPruningPointUtxoSetOverrideResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_StopNotifyingPruningPointUtxoSetOverrideResponseMessage, rhs: Protowire_StopNotifyingPruningPointUtxoSetOverrideResponseMessage) -> Bool {
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_BanRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".BanRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ip"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.ip.isEmpty {
            try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_BanRequestMessage, rhs: Protowire_BanRequestMessage) -> Bool {
        if lhs.ip != rhs.ip {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_BanResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".BanResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_BanResponseMessage, rhs: Protowire_BanResponseMessage) -> Bool {
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_UnbanRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UnbanRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "ip"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.ip.isEmpty {
            try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_UnbanRequestMessage, rhs: Protowire_UnbanRequestMessage) -> Bool {
        if lhs.ip != rhs.ip {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_UnbanResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".UnbanResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_UnbanResponseMessage, rhs: Protowire_UnbanResponseMessage) -> Bool {
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetInfoRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetInfoRequestMessage"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetInfoRequestMessage, rhs: Protowire_GetInfoRequestMessage) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetInfoResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetInfoResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "p2pId"),
        2: .same(proto: "mempoolSize"),
        3: .same(proto: "serverVersion"),
        4: .same(proto: "isUtxoIndexed"),
        5: .same(proto: "isSynced"),
        11: .same(proto: "hasNotifyCommand"),
        12: .same(proto: "hasMessageId"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.p2PID) }()
            case 2: try { try decoder.decodeSingularUInt64Field(value: &self.mempoolSize) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.serverVersion) }()
            case 4: try { try decoder.decodeSingularBoolField(value: &self.isUtxoIndexed) }()
            case 5: try { try decoder.decodeSingularBoolField(value: &self.isSynced) }()
            case 11: try { try decoder.decodeSingularBoolField(value: &self.hasNotifyCommand_p) }()
            case 12: try { try decoder.decodeSingularBoolField(value: &self.hasMessageID_p) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.p2PID.isEmpty {
            try visitor.visitSingularStringField(value: self.p2PID, fieldNumber: 1)
        }
        if self.mempoolSize != 0 {
            try visitor.visitSingularUInt64Field(value: self.mempoolSize, fieldNumber: 2)
        }
        if !self.serverVersion.isEmpty {
            try visitor.visitSingularStringField(value: self.serverVersion, fieldNumber: 3)
        }
        if self.isUtxoIndexed != false {
            try visitor.visitSingularBoolField(value: self.isUtxoIndexed, fieldNumber: 4)
        }
        if self.isSynced != false {
            try visitor.visitSingularBoolField(value: self.isSynced, fieldNumber: 5)
        }
        if self.hasNotifyCommand_p != false {
            try visitor.visitSingularBoolField(value: self.hasNotifyCommand_p, fieldNumber: 11)
        }
        if self.hasMessageID_p != false {
            try visitor.visitSingularBoolField(value: self.hasMessageID_p, fieldNumber: 12)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetInfoResponseMessage, rhs: Protowire_GetInfoResponseMessage) -> Bool {
        if lhs.p2PID != rhs.p2PID {return false}
        if lhs.mempoolSize != rhs.mempoolSize {return false}
        if lhs.serverVersion != rhs.serverVersion {return false}
        if lhs.isUtxoIndexed != rhs.isUtxoIndexed {return false}
        if lhs.isSynced != rhs.isSynced {return false}
        if lhs.hasNotifyCommand_p != rhs.hasNotifyCommand_p {return false}
        if lhs.hasMessageID_p != rhs.hasMessageID_p {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_EstimateNetworkHashesPerSecondRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".EstimateNetworkHashesPerSecondRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "windowSize"),
        2: .same(proto: "startHash"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt32Field(value: &self.windowSize) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.startHash) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.windowSize != 0 {
            try visitor.visitSingularUInt32Field(value: self.windowSize, fieldNumber: 1)
        }
        if !self.startHash.isEmpty {
            try visitor.visitSingularStringField(value: self.startHash, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_EstimateNetworkHashesPerSecondRequestMessage, rhs: Protowire_EstimateNetworkHashesPerSecondRequestMessage) -> Bool {
        if lhs.windowSize != rhs.windowSize {return false}
        if lhs.startHash != rhs.startHash {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_EstimateNetworkHashesPerSecondResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".EstimateNetworkHashesPerSecondResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "networkHashesPerSecond"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt64Field(value: &self.networkHashesPerSecond) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.networkHashesPerSecond != 0 {
            try visitor.visitSingularUInt64Field(value: self.networkHashesPerSecond, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_EstimateNetworkHashesPerSecondResponseMessage, rhs: Protowire_EstimateNetworkHashesPerSecondResponseMessage) -> Bool {
        if lhs.networkHashesPerSecond != rhs.networkHashesPerSecond {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_NotifyNewBlockTemplateRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NotifyNewBlockTemplateRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        101: .same(proto: "command"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 101: try { try decoder.decodeSingularEnumField(value: &self.command) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.command != .notifyStart {
            try visitor.visitSingularEnumField(value: self.command, fieldNumber: 101)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_NotifyNewBlockTemplateRequestMessage, rhs: Protowire_NotifyNewBlockTemplateRequestMessage) -> Bool {
        if lhs.command != rhs.command {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_NotifyNewBlockTemplateResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NotifyNewBlockTemplateResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_NotifyNewBlockTemplateResponseMessage, rhs: Protowire_NotifyNewBlockTemplateResponseMessage) -> Bool {
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_NewBlockTemplateNotificationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".NewBlockTemplateNotificationMessage"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_NewBlockTemplateNotificationMessage, rhs: Protowire_NewBlockTemplateNotificationMessage) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcMempoolEntryByAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcMempoolEntryByAddress"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "address"),
        2: .same(proto: "sending"),
        3: .same(proto: "receiving"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sending) }()
            case 3: try { try decoder.decodeRepeatedMessageField(value: &self.receiving) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.address.isEmpty {
            try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
        }
        if !self.sending.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.sending, fieldNumber: 2)
        }
        if !self.receiving.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.receiving, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_RpcMempoolEntryByAddress, rhs: Protowire_RpcMempoolEntryByAddress) -> Bool {
        if lhs.address != rhs.address {return false}
        if lhs.sending != rhs.sending {return false}
        if lhs.receiving != rhs.receiving {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetMempoolEntriesByAddressesRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetMempoolEntriesByAddressesRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "addresses"),
        2: .same(proto: "includeOrphanPool"),
        3: .same(proto: "filterTransactionPool"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
            case 2: try { try decoder.decodeSingularBoolField(value: &self.includeOrphanPool) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self.filterTransactionPool) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.addresses.isEmpty {
            try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 1)
        }
        if self.includeOrphanPool != false {
            try visitor.visitSingularBoolField(value: self.includeOrphanPool, fieldNumber: 2)
        }
        if self.filterTransactionPool != false {
            try visitor.visitSingularBoolField(value: self.filterTransactionPool, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetMempoolEntriesByAddressesRequestMessage, rhs: Protowire_GetMempoolEntriesByAddressesRequestMessage) -> Bool {
        if lhs.addresses != rhs.addresses {return false}
        if lhs.includeOrphanPool != rhs.includeOrphanPool {return false}
        if lhs.filterTransactionPool != rhs.filterTransactionPool {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetMempoolEntriesByAddressesResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetMempoolEntriesByAddressesResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "entries"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.entries.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetMempoolEntriesByAddressesResponseMessage, rhs: Protowire_GetMempoolEntriesByAddressesResponseMessage) -> Bool {
        if lhs.entries != rhs.entries {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetCoinSupplyRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetCoinSupplyRequestMessage"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetCoinSupplyRequestMessage, rhs: Protowire_GetCoinSupplyRequestMessage) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetCoinSupplyResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetCoinSupplyResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "maxSompi"),
        2: .same(proto: "circulatingSompi"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt64Field(value: &self.maxSompi) }()
            case 2: try { try decoder.decodeSingularUInt64Field(value: &self.circulatingSompi) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.maxSompi != 0 {
            try visitor.visitSingularUInt64Field(value: self.maxSompi, fieldNumber: 1)
        }
        if self.circulatingSompi != 0 {
            try visitor.visitSingularUInt64Field(value: self.circulatingSompi, fieldNumber: 2)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetCoinSupplyResponseMessage, rhs: Protowire_GetCoinSupplyResponseMessage) -> Bool {
        if lhs.maxSompi != rhs.maxSompi {return false}
        if lhs.circulatingSompi != rhs.circulatingSompi {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_PingRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".PingRequestMessage"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_PingRequestMessage, rhs: Protowire_PingRequestMessage) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_PingResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".PingResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_PingResponseMessage, rhs: Protowire_PingResponseMessage) -> Bool {
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_ProcessMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ProcessMetrics"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "residentSetSize"),
        2: .same(proto: "virtualMemorySize"),
        3: .same(proto: "coreNum"),
        4: .same(proto: "cpuUsage"),
        5: .same(proto: "fdNum"),
        6: .same(proto: "diskIoReadBytes"),
        7: .same(proto: "diskIoWriteBytes"),
        8: .same(proto: "diskIoReadPerSec"),
        9: .same(proto: "diskIoWritePerSec"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt64Field(value: &self.residentSetSize) }()
            case 2: try { try decoder.decodeSingularUInt64Field(value: &self.virtualMemorySize) }()
            case 3: try { try decoder.decodeSingularUInt32Field(value: &self.coreNum) }()
            case 4: try { try decoder.decodeSingularFloatField(value: &self.cpuUsage) }()
            case 5: try { try decoder.decodeSingularUInt32Field(value: &self.fdNum) }()
            case 6: try { try decoder.decodeSingularUInt64Field(value: &self.diskIoReadBytes) }()
            case 7: try { try decoder.decodeSingularUInt64Field(value: &self.diskIoWriteBytes) }()
            case 8: try { try decoder.decodeSingularFloatField(value: &self.diskIoReadPerSec) }()
            case 9: try { try decoder.decodeSingularFloatField(value: &self.diskIoWritePerSec) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.residentSetSize != 0 {
            try visitor.visitSingularUInt64Field(value: self.residentSetSize, fieldNumber: 1)
        }
        if self.virtualMemorySize != 0 {
            try visitor.visitSingularUInt64Field(value: self.virtualMemorySize, fieldNumber: 2)
        }
        if self.coreNum != 0 {
            try visitor.visitSingularUInt32Field(value: self.coreNum, fieldNumber: 3)
        }
        if self.cpuUsage.bitPattern != 0 {
            try visitor.visitSingularFloatField(value: self.cpuUsage, fieldNumber: 4)
        }
        if self.fdNum != 0 {
            try visitor.visitSingularUInt32Field(value: self.fdNum, fieldNumber: 5)
        }
        if self.diskIoReadBytes != 0 {
            try visitor.visitSingularUInt64Field(value: self.diskIoReadBytes, fieldNumber: 6)
        }
        if self.diskIoWriteBytes != 0 {
            try visitor.visitSingularUInt64Field(value: self.diskIoWriteBytes, fieldNumber: 7)
        }
        if self.diskIoReadPerSec.bitPattern != 0 {
            try visitor.visitSingularFloatField(value: self.diskIoReadPerSec, fieldNumber: 8)
        }
        if self.diskIoWritePerSec.bitPattern != 0 {
            try visitor.visitSingularFloatField(value: self.diskIoWritePerSec, fieldNumber: 9)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_ProcessMetrics, rhs: Protowire_ProcessMetrics) -> Bool {
        if lhs.residentSetSize != rhs.residentSetSize {return false}
        if lhs.virtualMemorySize != rhs.virtualMemorySize {return false}
        if lhs.coreNum != rhs.coreNum {return false}
        if lhs.cpuUsage != rhs.cpuUsage {return false}
        if lhs.fdNum != rhs.fdNum {return false}
        if lhs.diskIoReadBytes != rhs.diskIoReadBytes {return false}
        if lhs.diskIoWriteBytes != rhs.diskIoWriteBytes {return false}
        if lhs.diskIoReadPerSec != rhs.diskIoReadPerSec {return false}
        if lhs.diskIoWritePerSec != rhs.diskIoWritePerSec {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_ConnectionMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ConnectionMetrics"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        31: .same(proto: "borshLiveConnections"),
        32: .same(proto: "borshConnectionAttempts"),
        33: .same(proto: "borshHandshakeFailures"),
        41: .same(proto: "jsonLiveConnections"),
        42: .same(proto: "jsonConnectionAttempts"),
        43: .same(proto: "jsonHandshakeFailures"),
        51: .same(proto: "activePeers"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 31: try { try decoder.decodeSingularUInt32Field(value: &self.borshLiveConnections) }()
            case 32: try { try decoder.decodeSingularUInt64Field(value: &self.borshConnectionAttempts) }()
            case 33: try { try decoder.decodeSingularUInt64Field(value: &self.borshHandshakeFailures) }()
            case 41: try { try decoder.decodeSingularUInt32Field(value: &self.jsonLiveConnections) }()
            case 42: try { try decoder.decodeSingularUInt64Field(value: &self.jsonConnectionAttempts) }()
            case 43: try { try decoder.decodeSingularUInt64Field(value: &self.jsonHandshakeFailures) }()
            case 51: try { try decoder.decodeSingularUInt32Field(value: &self.activePeers) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.borshLiveConnections != 0 {
            try visitor.visitSingularUInt32Field(value: self.borshLiveConnections, fieldNumber: 31)
        }
        if self.borshConnectionAttempts != 0 {
            try visitor.visitSingularUInt64Field(value: self.borshConnectionAttempts, fieldNumber: 32)
        }
        if self.borshHandshakeFailures != 0 {
            try visitor.visitSingularUInt64Field(value: self.borshHandshakeFailures, fieldNumber: 33)
        }
        if self.jsonLiveConnections != 0 {
            try visitor.visitSingularUInt32Field(value: self.jsonLiveConnections, fieldNumber: 41)
        }
        if self.jsonConnectionAttempts != 0 {
            try visitor.visitSingularUInt64Field(value: self.jsonConnectionAttempts, fieldNumber: 42)
        }
        if self.jsonHandshakeFailures != 0 {
            try visitor.visitSingularUInt64Field(value: self.jsonHandshakeFailures, fieldNumber: 43)
        }
        if self.activePeers != 0 {
            try visitor.visitSingularUInt32Field(value: self.activePeers, fieldNumber: 51)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_ConnectionMetrics, rhs: Protowire_ConnectionMetrics) -> Bool {
        if lhs.borshLiveConnections != rhs.borshLiveConnections {return false}
        if lhs.borshConnectionAttempts != rhs.borshConnectionAttempts {return false}
        if lhs.borshHandshakeFailures != rhs.borshHandshakeFailures {return false}
        if lhs.jsonLiveConnections != rhs.jsonLiveConnections {return false}
        if lhs.jsonConnectionAttempts != rhs.jsonConnectionAttempts {return false}
        if lhs.jsonHandshakeFailures != rhs.jsonHandshakeFailures {return false}
        if lhs.activePeers != rhs.activePeers {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_BandwidthMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".BandwidthMetrics"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        61: .same(proto: "borshBytesTx"),
        62: .same(proto: "borshBytesRx"),
        63: .same(proto: "jsonBytesTx"),
        64: .same(proto: "jsonBytesRx"),
        65: .same(proto: "grpcP2pBytesTx"),
        66: .same(proto: "grpcP2pBytesRx"),
        67: .same(proto: "grpcUserBytesTx"),
        68: .same(proto: "grpcUserBytesRx"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 61: try { try decoder.decodeSingularUInt64Field(value: &self.borshBytesTx) }()
            case 62: try { try decoder.decodeSingularUInt64Field(value: &self.borshBytesRx) }()
            case 63: try { try decoder.decodeSingularUInt64Field(value: &self.jsonBytesTx) }()
            case 64: try { try decoder.decodeSingularUInt64Field(value: &self.jsonBytesRx) }()
            case 65: try { try decoder.decodeSingularUInt64Field(value: &self.grpcP2PBytesTx) }()
            case 66: try { try decoder.decodeSingularUInt64Field(value: &self.grpcP2PBytesRx) }()
            case 67: try { try decoder.decodeSingularUInt64Field(value: &self.grpcUserBytesTx) }()
            case 68: try { try decoder.decodeSingularUInt64Field(value: &self.grpcUserBytesRx) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.borshBytesTx != 0 {
            try visitor.visitSingularUInt64Field(value: self.borshBytesTx, fieldNumber: 61)
        }
        if self.borshBytesRx != 0 {
            try visitor.visitSingularUInt64Field(value: self.borshBytesRx, fieldNumber: 62)
        }
        if self.jsonBytesTx != 0 {
            try visitor.visitSingularUInt64Field(value: self.jsonBytesTx, fieldNumber: 63)
        }
        if self.jsonBytesRx != 0 {
            try visitor.visitSingularUInt64Field(value: self.jsonBytesRx, fieldNumber: 64)
        }
        if self.grpcP2PBytesTx != 0 {
            try visitor.visitSingularUInt64Field(value: self.grpcP2PBytesTx, fieldNumber: 65)
        }
        if self.grpcP2PBytesRx != 0 {
            try visitor.visitSingularUInt64Field(value: self.grpcP2PBytesRx, fieldNumber: 66)
        }
        if self.grpcUserBytesTx != 0 {
            try visitor.visitSingularUInt64Field(value: self.grpcUserBytesTx, fieldNumber: 67)
        }
        if self.grpcUserBytesRx != 0 {
            try visitor.visitSingularUInt64Field(value: self.grpcUserBytesRx, fieldNumber: 68)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_BandwidthMetrics, rhs: Protowire_BandwidthMetrics) -> Bool {
        if lhs.borshBytesTx != rhs.borshBytesTx {return false}
        if lhs.borshBytesRx != rhs.borshBytesRx {return false}
        if lhs.jsonBytesTx != rhs.jsonBytesTx {return false}
        if lhs.jsonBytesRx != rhs.jsonBytesRx {return false}
        if lhs.grpcP2PBytesTx != rhs.grpcP2PBytesTx {return false}
        if lhs.grpcP2PBytesRx != rhs.grpcP2PBytesRx {return false}
        if lhs.grpcUserBytesTx != rhs.grpcUserBytesTx {return false}
        if lhs.grpcUserBytesRx != rhs.grpcUserBytesRx {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_ConsensusMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ConsensusMetrics"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "blocksSubmitted"),
        2: .same(proto: "headerCounts"),
        3: .same(proto: "depCounts"),
        4: .same(proto: "bodyCounts"),
        5: .same(proto: "txsCounts"),
        6: .same(proto: "chainBlockCounts"),
        7: .same(proto: "massCounts"),
        11: .same(proto: "blockCount"),
        12: .same(proto: "headerCount"),
        13: .same(proto: "mempoolSize"),
        14: .same(proto: "tipHashesCount"),
        15: .same(proto: "difficulty"),
        16: .same(proto: "pastMedianTime"),
        17: .same(proto: "virtualParentHashesCount"),
        18: .same(proto: "virtualDaaScore"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt64Field(value: &self.blocksSubmitted) }()
            case 2: try { try decoder.decodeSingularUInt64Field(value: &self.headerCounts) }()
            case 3: try { try decoder.decodeSingularUInt64Field(value: &self.depCounts) }()
            case 4: try { try decoder.decodeSingularUInt64Field(value: &self.bodyCounts) }()
            case 5: try { try decoder.decodeSingularUInt64Field(value: &self.txsCounts) }()
            case 6: try { try decoder.decodeSingularUInt64Field(value: &self.chainBlockCounts) }()
            case 7: try { try decoder.decodeSingularUInt64Field(value: &self.massCounts) }()
            case 11: try { try decoder.decodeSingularUInt64Field(value: &self.blockCount) }()
            case 12: try { try decoder.decodeSingularUInt64Field(value: &self.headerCount) }()
            case 13: try { try decoder.decodeSingularUInt64Field(value: &self.mempoolSize) }()
            case 14: try { try decoder.decodeSingularUInt32Field(value: &self.tipHashesCount) }()
            case 15: try { try decoder.decodeSingularDoubleField(value: &self.difficulty) }()
            case 16: try { try decoder.decodeSingularUInt64Field(value: &self.pastMedianTime) }()
            case 17: try { try decoder.decodeSingularUInt32Field(value: &self.virtualParentHashesCount) }()
            case 18: try { try decoder.decodeSingularUInt64Field(value: &self.virtualDaaScore) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.blocksSubmitted != 0 {
            try visitor.visitSingularUInt64Field(value: self.blocksSubmitted, fieldNumber: 1)
        }
        if self.headerCounts != 0 {
            try visitor.visitSingularUInt64Field(value: self.headerCounts, fieldNumber: 2)
        }
        if self.depCounts != 0 {
            try visitor.visitSingularUInt64Field(value: self.depCounts, fieldNumber: 3)
        }
        if self.bodyCounts != 0 {
            try visitor.visitSingularUInt64Field(value: self.bodyCounts, fieldNumber: 4)
        }
        if self.txsCounts != 0 {
            try visitor.visitSingularUInt64Field(value: self.txsCounts, fieldNumber: 5)
        }
        if self.chainBlockCounts != 0 {
            try visitor.visitSingularUInt64Field(value: self.chainBlockCounts, fieldNumber: 6)
        }
        if self.massCounts != 0 {
            try visitor.visitSingularUInt64Field(value: self.massCounts, fieldNumber: 7)
        }
        if self.blockCount != 0 {
            try visitor.visitSingularUInt64Field(value: self.blockCount, fieldNumber: 11)
        }
        if self.headerCount != 0 {
            try visitor.visitSingularUInt64Field(value: self.headerCount, fieldNumber: 12)
        }
        if self.mempoolSize != 0 {
            try visitor.visitSingularUInt64Field(value: self.mempoolSize, fieldNumber: 13)
        }
        if self.tipHashesCount != 0 {
            try visitor.visitSingularUInt32Field(value: self.tipHashesCount, fieldNumber: 14)
        }
        if self.difficulty.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: self.difficulty, fieldNumber: 15)
        }
        if self.pastMedianTime != 0 {
            try visitor.visitSingularUInt64Field(value: self.pastMedianTime, fieldNumber: 16)
        }
        if self.virtualParentHashesCount != 0 {
            try visitor.visitSingularUInt32Field(value: self.virtualParentHashesCount, fieldNumber: 17)
        }
        if self.virtualDaaScore != 0 {
            try visitor.visitSingularUInt64Field(value: self.virtualDaaScore, fieldNumber: 18)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_ConsensusMetrics, rhs: Protowire_ConsensusMetrics) -> Bool {
        if lhs.blocksSubmitted != rhs.blocksSubmitted {return false}
        if lhs.headerCounts != rhs.headerCounts {return false}
        if lhs.depCounts != rhs.depCounts {return false}
        if lhs.bodyCounts != rhs.bodyCounts {return false}
        if lhs.txsCounts != rhs.txsCounts {return false}
        if lhs.chainBlockCounts != rhs.chainBlockCounts {return false}
        if lhs.massCounts != rhs.massCounts {return false}
        if lhs.blockCount != rhs.blockCount {return false}
        if lhs.headerCount != rhs.headerCount {return false}
        if lhs.mempoolSize != rhs.mempoolSize {return false}
        if lhs.tipHashesCount != rhs.tipHashesCount {return false}
        if lhs.difficulty != rhs.difficulty {return false}
        if lhs.pastMedianTime != rhs.pastMedianTime {return false}
        if lhs.virtualParentHashesCount != rhs.virtualParentHashesCount {return false}
        if lhs.virtualDaaScore != rhs.virtualDaaScore {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_StorageMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".StorageMetrics"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "storageSizeBytes"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt64Field(value: &self.storageSizeBytes) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.storageSizeBytes != 0 {
            try visitor.visitSingularUInt64Field(value: self.storageSizeBytes, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_StorageMetrics, rhs: Protowire_StorageMetrics) -> Bool {
        if lhs.storageSizeBytes != rhs.storageSizeBytes {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetConnectionsRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetConnectionsRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "includeProfileData"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBoolField(value: &self.includeProfileData) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.includeProfileData != false {
            try visitor.visitSingularBoolField(value: self.includeProfileData, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetConnectionsRequestMessage, rhs: Protowire_GetConnectionsRequestMessage) -> Bool {
        if lhs.includeProfileData != rhs.includeProfileData {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_ConnectionsProfileData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".ConnectionsProfileData"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "cpuUsage"),
        2: .same(proto: "memoryUsage"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularDoubleField(value: &self.cpuUsage) }()
            case 2: try { try decoder.decodeSingularUInt64Field(value: &self.memoryUsage) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.cpuUsage.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: self.cpuUsage, fieldNumber: 1)
        }
        if self.memoryUsage != 0 {
            try visitor.visitSingularUInt64Field(value: self.memoryUsage, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_ConnectionsProfileData, rhs: Protowire_ConnectionsProfileData) -> Bool {
        if lhs.cpuUsage != rhs.cpuUsage {return false}
        if lhs.memoryUsage != rhs.memoryUsage {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetConnectionsResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetConnectionsResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "clients"),
        2: .same(proto: "peers"),
        3: .same(proto: "profileData"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt32Field(value: &self.clients) }()
            case 2: try { try decoder.decodeSingularUInt32Field(value: &self.peers) }()
            case 3: try { try decoder.decodeSingularMessageField(value: &self._profileData) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.clients != 0 {
            try visitor.visitSingularUInt32Field(value: self.clients, fieldNumber: 1)
        }
        if self.peers != 0 {
            try visitor.visitSingularUInt32Field(value: self.peers, fieldNumber: 2)
        }
        try { if let v = self._profileData {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetConnectionsResponseMessage, rhs: Protowire_GetConnectionsResponseMessage) -> Bool {
        if lhs.clients != rhs.clients {return false}
        if lhs.peers != rhs.peers {return false}
        if lhs._profileData != rhs._profileData {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetSystemInfoRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetSystemInfoRequestMessage"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetSystemInfoRequestMessage, rhs: Protowire_GetSystemInfoRequestMessage) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetSystemInfoResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetSystemInfoResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "version"),
        2: .same(proto: "systemId"),
        3: .same(proto: "gitHash"),
        4: .same(proto: "coreNum"),
        5: .same(proto: "totalMemory"),
        6: .same(proto: "fdLimit"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
            case 2: try { try decoder.decodeSingularStringField(value: &self.systemID) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.gitHash) }()
            case 4: try { try decoder.decodeSingularUInt32Field(value: &self.coreNum) }()
            case 5: try { try decoder.decodeSingularUInt64Field(value: &self.totalMemory) }()
            case 6: try { try decoder.decodeSingularUInt32Field(value: &self.fdLimit) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.version.isEmpty {
            try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
        }
        if !self.systemID.isEmpty {
            try visitor.visitSingularStringField(value: self.systemID, fieldNumber: 2)
        }
        if !self.gitHash.isEmpty {
            try visitor.visitSingularStringField(value: self.gitHash, fieldNumber: 3)
        }
        if self.coreNum != 0 {
            try visitor.visitSingularUInt32Field(value: self.coreNum, fieldNumber: 4)
        }
        if self.totalMemory != 0 {
            try visitor.visitSingularUInt64Field(value: self.totalMemory, fieldNumber: 5)
        }
        if self.fdLimit != 0 {
            try visitor.visitSingularUInt32Field(value: self.fdLimit, fieldNumber: 6)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetSystemInfoResponseMessage, rhs: Protowire_GetSystemInfoResponseMessage) -> Bool {
        if lhs.version != rhs.version {return false}
        if lhs.systemID != rhs.systemID {return false}
        if lhs.gitHash != rhs.gitHash {return false}
        if lhs.coreNum != rhs.coreNum {return false}
        if lhs.totalMemory != rhs.totalMemory {return false}
        if lhs.fdLimit != rhs.fdLimit {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetMetricsRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetMetricsRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "processMetrics"),
        2: .same(proto: "connectionMetrics"),
        3: .same(proto: "bandwidthMetrics"),
        4: .same(proto: "consensusMetrics"),
        5: .same(proto: "storageMetrics"),
        6: .same(proto: "customMetrics"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBoolField(value: &self.processMetrics) }()
            case 2: try { try decoder.decodeSingularBoolField(value: &self.connectionMetrics) }()
            case 3: try { try decoder.decodeSingularBoolField(value: &self.bandwidthMetrics) }()
            case 4: try { try decoder.decodeSingularBoolField(value: &self.consensusMetrics) }()
            case 5: try { try decoder.decodeSingularBoolField(value: &self.storageMetrics) }()
            case 6: try { try decoder.decodeSingularBoolField(value: &self.customMetrics) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.processMetrics != false {
            try visitor.visitSingularBoolField(value: self.processMetrics, fieldNumber: 1)
        }
        if self.connectionMetrics != false {
            try visitor.visitSingularBoolField(value: self.connectionMetrics, fieldNumber: 2)
        }
        if self.bandwidthMetrics != false {
            try visitor.visitSingularBoolField(value: self.bandwidthMetrics, fieldNumber: 3)
        }
        if self.consensusMetrics != false {
            try visitor.visitSingularBoolField(value: self.consensusMetrics, fieldNumber: 4)
        }
        if self.storageMetrics != false {
            try visitor.visitSingularBoolField(value: self.storageMetrics, fieldNumber: 5)
        }
        if self.customMetrics != false {
            try visitor.visitSingularBoolField(value: self.customMetrics, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetMetricsRequestMessage, rhs: Protowire_GetMetricsRequestMessage) -> Bool {
        if lhs.processMetrics != rhs.processMetrics {return false}
        if lhs.connectionMetrics != rhs.connectionMetrics {return false}
        if lhs.bandwidthMetrics != rhs.bandwidthMetrics {return false}
        if lhs.consensusMetrics != rhs.consensusMetrics {return false}
        if lhs.storageMetrics != rhs.storageMetrics {return false}
        if lhs.customMetrics != rhs.customMetrics {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetMetricsResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetMetricsResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "serverTime"),
        11: .same(proto: "processMetrics"),
        12: .same(proto: "connectionMetrics"),
        13: .same(proto: "bandwidthMetrics"),
        14: .same(proto: "consensusMetrics"),
        15: .same(proto: "storageMetrics"),
        1000: .same(proto: "error"),
    ]
    
    public class _StorageClass {
        public var _serverTime: UInt64 = 0
        public var _processMetrics: Protowire_ProcessMetrics? = nil
        public var _connectionMetrics: Protowire_ConnectionMetrics? = nil
        public var _bandwidthMetrics: Protowire_BandwidthMetrics? = nil
        public var _consensusMetrics: Protowire_ConsensusMetrics? = nil
        public var _storageMetrics: Protowire_StorageMetrics? = nil
        public var _error: Protowire_RPCError? = nil
        
#if swift(>=5.10)
        // This property is used as the initial default value for new instances of the type.
        // The type itself is protecting the reference to its storage via CoW semantics.
        // This will force a copy to be made of this reference when the first mutation occurs;
        // hence, it is safe to mark this as `nonisolated(unsafe)`.
        static nonisolated(unsafe) let defaultInstance = _StorageClass()
#else
        public static let defaultInstance = _StorageClass()
#endif
        
        public init() {}
        
        init(copying source: _StorageClass) {
            _serverTime = source._serverTime
            _processMetrics = source._processMetrics
            _connectionMetrics = source._connectionMetrics
            _bandwidthMetrics = source._bandwidthMetrics
            _consensusMetrics = source._consensusMetrics
            _storageMetrics = source._storageMetrics
            _error = source._error
        }
    }
    
    public mutating func _uniqueStorage() -> _StorageClass {
        if !isKnownUniquelyReferenced(&_storage) {
            _storage = _StorageClass(copying: _storage)
        }
        return _storage
    }
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        _ = _uniqueStorage()
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            while let fieldNumber = try decoder.nextFieldNumber() {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch fieldNumber {
                case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._serverTime) }()
                case 11: try { try decoder.decodeSingularMessageField(value: &_storage._processMetrics) }()
                case 12: try { try decoder.decodeSingularMessageField(value: &_storage._connectionMetrics) }()
                case 13: try { try decoder.decodeSingularMessageField(value: &_storage._bandwidthMetrics) }()
                case 14: try { try decoder.decodeSingularMessageField(value: &_storage._consensusMetrics) }()
                case 15: try { try decoder.decodeSingularMessageField(value: &_storage._storageMetrics) }()
                case 1000: try { try decoder.decodeSingularMessageField(value: &_storage._error) }()
                default: break
                }
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every if/case branch local when no optimizations
            // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
            // https://github.com/apple/swift-protobuf/issues/1182
            if _storage._serverTime != 0 {
                try visitor.visitSingularUInt64Field(value: _storage._serverTime, fieldNumber: 1)
            }
            try { if let v = _storage._processMetrics {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
            } }()
            try { if let v = _storage._connectionMetrics {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
            } }()
            try { if let v = _storage._bandwidthMetrics {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
            } }()
            try { if let v = _storage._consensusMetrics {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
            } }()
            try { if let v = _storage._storageMetrics {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
            } }()
            try { if let v = _storage._error {
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
            } }()
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetMetricsResponseMessage, rhs: Protowire_GetMetricsResponseMessage) -> Bool {
        if lhs._storage !== rhs._storage {
            let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
                let _storage = _args.0
                let rhs_storage = _args.1
                if _storage._serverTime != rhs_storage._serverTime {return false}
                if _storage._processMetrics != rhs_storage._processMetrics {return false}
                if _storage._connectionMetrics != rhs_storage._connectionMetrics {return false}
                if _storage._bandwidthMetrics != rhs_storage._bandwidthMetrics {return false}
                if _storage._consensusMetrics != rhs_storage._consensusMetrics {return false}
                if _storage._storageMetrics != rhs_storage._storageMetrics {return false}
                if _storage._error != rhs_storage._error {return false}
                return true
            }
            if !storagesAreEqual {return false}
        }
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetServerInfoRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetServerInfoRequestMessage"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetServerInfoRequestMessage, rhs: Protowire_GetServerInfoRequestMessage) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetServerInfoResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetServerInfoResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "rpcApiVersion"),
        2: .same(proto: "rpcApiRevision"),
        3: .same(proto: "serverVersion"),
        4: .same(proto: "networkId"),
        5: .same(proto: "hasUtxoIndex"),
        6: .same(proto: "isSynced"),
        7: .same(proto: "virtualDaaScore"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt32Field(value: &self.rpcApiVersion) }()
            case 2: try { try decoder.decodeSingularUInt32Field(value: &self.rpcApiRevision) }()
            case 3: try { try decoder.decodeSingularStringField(value: &self.serverVersion) }()
            case 4: try { try decoder.decodeSingularStringField(value: &self.networkID) }()
            case 5: try { try decoder.decodeSingularBoolField(value: &self.hasUtxoIndex_p) }()
            case 6: try { try decoder.decodeSingularBoolField(value: &self.isSynced) }()
            case 7: try { try decoder.decodeSingularUInt64Field(value: &self.virtualDaaScore) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.rpcApiVersion != 0 {
            try visitor.visitSingularUInt32Field(value: self.rpcApiVersion, fieldNumber: 1)
        }
        if self.rpcApiRevision != 0 {
            try visitor.visitSingularUInt32Field(value: self.rpcApiRevision, fieldNumber: 2)
        }
        if !self.serverVersion.isEmpty {
            try visitor.visitSingularStringField(value: self.serverVersion, fieldNumber: 3)
        }
        if !self.networkID.isEmpty {
            try visitor.visitSingularStringField(value: self.networkID, fieldNumber: 4)
        }
        if self.hasUtxoIndex_p != false {
            try visitor.visitSingularBoolField(value: self.hasUtxoIndex_p, fieldNumber: 5)
        }
        if self.isSynced != false {
            try visitor.visitSingularBoolField(value: self.isSynced, fieldNumber: 6)
        }
        if self.virtualDaaScore != 0 {
            try visitor.visitSingularUInt64Field(value: self.virtualDaaScore, fieldNumber: 7)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetServerInfoResponseMessage, rhs: Protowire_GetServerInfoResponseMessage) -> Bool {
        if lhs.rpcApiVersion != rhs.rpcApiVersion {return false}
        if lhs.rpcApiRevision != rhs.rpcApiRevision {return false}
        if lhs.serverVersion != rhs.serverVersion {return false}
        if lhs.networkID != rhs.networkID {return false}
        if lhs.hasUtxoIndex_p != rhs.hasUtxoIndex_p {return false}
        if lhs.isSynced != rhs.isSynced {return false}
        if lhs.virtualDaaScore != rhs.virtualDaaScore {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetSyncStatusRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetSyncStatusRequestMessage"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetSyncStatusRequestMessage, rhs: Protowire_GetSyncStatusRequestMessage) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetSyncStatusResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetSyncStatusResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "isSynced"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBoolField(value: &self.isSynced) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.isSynced != false {
            try visitor.visitSingularBoolField(value: self.isSynced, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetSyncStatusResponseMessage, rhs: Protowire_GetSyncStatusResponseMessage) -> Bool {
        if lhs.isSynced != rhs.isSynced {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetDaaScoreTimestampEstimateRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetDaaScoreTimestampEstimateRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "daa_scores"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.daaScores) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.daaScores.isEmpty {
            try visitor.visitPackedUInt64Field(value: self.daaScores, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetDaaScoreTimestampEstimateRequestMessage, rhs: Protowire_GetDaaScoreTimestampEstimateRequestMessage) -> Bool {
        if lhs.daaScores != rhs.daaScores {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetDaaScoreTimestampEstimateResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetDaaScoreTimestampEstimateResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "timestamps"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.timestamps) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !self.timestamps.isEmpty {
            try visitor.visitPackedUInt64Field(value: self.timestamps, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_GetDaaScoreTimestampEstimateResponseMessage, rhs: Protowire_GetDaaScoreTimestampEstimateResponseMessage) -> Bool {
        if lhs.timestamps != rhs.timestamps {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcFeerateBucket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcFeerateBucket"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "feerate"),
        2: .standard(proto: "estimated_seconds"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularDoubleField(value: &self.feerate) }()
            case 2: try { try decoder.decodeSingularDoubleField(value: &self.estimatedSeconds) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.feerate.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: self.feerate, fieldNumber: 1)
        }
        if self.estimatedSeconds.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: self.estimatedSeconds, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_RpcFeerateBucket, rhs: Protowire_RpcFeerateBucket) -> Bool {
        if lhs.feerate != rhs.feerate {return false}
        if lhs.estimatedSeconds != rhs.estimatedSeconds {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcFeeEstimate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcFeeEstimate"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "priority_bucket"),
        2: .standard(proto: "normal_buckets"),
        3: .standard(proto: "low_buckets"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._priorityBucket) }()
            case 2: try { try decoder.decodeRepeatedMessageField(value: &self.normalBuckets) }()
            case 3: try { try decoder.decodeRepeatedMessageField(value: &self.lowBuckets) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._priorityBucket {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !self.normalBuckets.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.normalBuckets, fieldNumber: 2)
        }
        if !self.lowBuckets.isEmpty {
            try visitor.visitRepeatedMessageField(value: self.lowBuckets, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    public static func ==(lhs: Protowire_RpcFeeEstimate, rhs: Protowire_RpcFeeEstimate) -> Bool {
        if lhs._priorityBucket != rhs._priorityBucket {return false}
        if lhs.normalBuckets != rhs.normalBuckets {return false}
        if lhs.lowBuckets != rhs.lowBuckets {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_RpcFeeEstimateVerboseExperimentalData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".RpcFeeEstimateVerboseExperimentalData"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "mempool_ready_transactions_count"),
        2: .standard(proto: "mempool_ready_transactions_total_mass"),
        3: .standard(proto: "network_mass_per_second"),
        11: .standard(proto: "next_block_template_feerate_min"),
        12: .standard(proto: "next_block_template_feerate_median"),
        13: .standard(proto: "next_block_template_feerate_max"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularUInt64Field(value: &self.mempoolReadyTransactionsCount) }()
            case 2: try { try decoder.decodeSingularUInt64Field(value: &self.mempoolReadyTransactionsTotalMass) }()
            case 3: try { try decoder.decodeSingularUInt64Field(value: &self.networkMassPerSecond) }()
            case 11: try { try decoder.decodeSingularDoubleField(value: &self.nextBlockTemplateFeerateMin) }()
            case 12: try { try decoder.decodeSingularDoubleField(value: &self.nextBlockTemplateFeerateMedian) }()
            case 13: try { try decoder.decodeSingularDoubleField(value: &self.nextBlockTemplateFeerateMax) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.mempoolReadyTransactionsCount != 0 {
            try visitor.visitSingularUInt64Field(value: self.mempoolReadyTransactionsCount, fieldNumber: 1)
        }
        if self.mempoolReadyTransactionsTotalMass != 0 {
            try visitor.visitSingularUInt64Field(value: self.mempoolReadyTransactionsTotalMass, fieldNumber: 2)
        }
        if self.networkMassPerSecond != 0 {
            try visitor.visitSingularUInt64Field(value: self.networkMassPerSecond, fieldNumber: 3)
        }
        if self.nextBlockTemplateFeerateMin.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: self.nextBlockTemplateFeerateMin, fieldNumber: 11)
        }
        if self.nextBlockTemplateFeerateMedian.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: self.nextBlockTemplateFeerateMedian, fieldNumber: 12)
        }
        if self.nextBlockTemplateFeerateMax.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: self.nextBlockTemplateFeerateMax, fieldNumber: 13)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_RpcFeeEstimateVerboseExperimentalData, rhs: Protowire_RpcFeeEstimateVerboseExperimentalData) -> Bool {
        if lhs.mempoolReadyTransactionsCount != rhs.mempoolReadyTransactionsCount {return false}
        if lhs.mempoolReadyTransactionsTotalMass != rhs.mempoolReadyTransactionsTotalMass {return false}
        if lhs.networkMassPerSecond != rhs.networkMassPerSecond {return false}
        if lhs.nextBlockTemplateFeerateMin != rhs.nextBlockTemplateFeerateMin {return false}
        if lhs.nextBlockTemplateFeerateMedian != rhs.nextBlockTemplateFeerateMedian {return false}
        if lhs.nextBlockTemplateFeerateMax != rhs.nextBlockTemplateFeerateMax {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetFeeEstimateRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetFeeEstimateRequestMessage"
    public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetFeeEstimateRequestMessage, rhs: Protowire_GetFeeEstimateRequestMessage) -> Bool {
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetFeeEstimateResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetFeeEstimateResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "estimate"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._estimate) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._estimate {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetFeeEstimateResponseMessage, rhs: Protowire_GetFeeEstimateResponseMessage) -> Bool {
        if lhs._estimate != rhs._estimate {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetFeeEstimateExperimentalRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetFeeEstimateExperimentalRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "verbose"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBoolField(value: &self.verbose) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if self.verbose != false {
            try visitor.visitSingularBoolField(value: self.verbose, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetFeeEstimateExperimentalRequestMessage, rhs: Protowire_GetFeeEstimateExperimentalRequestMessage) -> Bool {
        if lhs.verbose != rhs.verbose {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetFeeEstimateExperimentalResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetFeeEstimateExperimentalResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "estimate"),
        2: .same(proto: "verbose"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._estimate) }()
            case 2: try { try decoder.decodeSingularMessageField(value: &self._verbose) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._estimate {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._verbose {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetFeeEstimateExperimentalResponseMessage, rhs: Protowire_GetFeeEstimateExperimentalResponseMessage) -> Bool {
        if lhs._estimate != rhs._estimate {return false}
        if lhs._verbose != rhs._verbose {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetCurrentBlockColorRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetCurrentBlockColorRequestMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "hash"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !self.hash.isEmpty {
            try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetCurrentBlockColorRequestMessage, rhs: Protowire_GetCurrentBlockColorRequestMessage) -> Bool {
        if lhs.hash != rhs.hash {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Protowire_GetCurrentBlockColorResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    public static let protoMessageName: String = _protobuf_package + ".GetCurrentBlockColorResponseMessage"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "blue"),
        1000: .same(proto: "error"),
    ]
    
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularBoolField(value: &self.blue) }()
            case 1000: try { try decoder.decodeSingularMessageField(value: &self._error) }()
            default: break
            }
        }
    }
    
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if self.blue != false {
            try visitor.visitSingularBoolField(value: self.blue, fieldNumber: 1)
        }
        try { if let v = self._error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1000)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static public func ==(lhs: Protowire_GetCurrentBlockColorResponseMessage, rhs: Protowire_GetCurrentBlockColorResponseMessage) -> Bool {
        if lhs.blue != rhs.blue {return false}
        if lhs._error != rhs._error {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}
